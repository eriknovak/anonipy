{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> Data anonymization package, supporting different anonymization strategies </p> <p> </p> <p>Documentation: https://eriknovak.github.io/anonipy</p> <p>Source code: https://github.com/eriknovak/anonipy</p> <p>The anonipy package is a python package for data anonymization. It is designed to be simple to use and highly customizable, supporting different anonymization strategies. Powered by LLMs.</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install anonipy\n</code></pre>"},{"location":"#upgrade","title":"Upgrade","text":"<pre><code>pip install anonipy --upgrade\n</code></pre>"},{"location":"#example","title":"Example","text":"<pre><code>original_text = \"\"\"\\\nMedical Record\n\nPatient Name: John Doe\nDate of Birth: 15-01-1985\nDate of Examination: 20-05-2024\nSocial Security Number: 123-45-6789\n\nExamination Procedure:\nJohn Doe underwent a routine physical examination. The procedure included measuring vital signs (blood pressure, heart rate, temperature), a comprehensive blood panel, and a cardiovascular stress test. The patient also reported occasional headaches and dizziness, prompting a neurological assessment and an MRI scan to rule out any underlying issues.\n\nMedication Prescribed:\n\nIbuprofen 200 mg: Take one tablet every 6-8 hours as needed for headache and pain relief.\nLisinopril 10 mg: Take one tablet daily to manage high blood pressure.\nNext Examination Date:\n15-11-2024\n\"\"\"\n</code></pre> <p>Use the language detector to detect the language of the text:</p> <pre><code>from anonipy.utils.language_detector import LanguageDetector\n\nlanguage_detector = LanguageDetector()\nlanguage = language_detector(original_text)\n</code></pre> <p>Prepare the entity extractor and extract the personal infomation from the original text:</p> <pre><code>from anonipy.anonymize.extractors import NERExtractor\n\n# define the labels to be extracted and anonymized\nlabels = [\n    {\"label\": \"name\", \"type\": \"string\"},\n    {\"label\": \"social security number\", \"type\": \"custom\"},\n    {\"label\": \"date of birth\", \"type\": \"date\"},\n    {\"label\": \"date\", \"type\": \"date\"},\n]\n\n# initialize the NER extractor for the language and labels\nextractor = NERExtractor(labels, lang=language, score_th=0.5)\n\n# extract the entities from the original text\ndoc, entities = extractor(original_text)\n\n# display the entities in the original text\nextractor.display(doc)\n</code></pre> <p>Use generators to create substitutes for the entities:</p> <pre><code>from anonipy.anonymize.generators import (\n    LLMLabelGenerator,\n    DateGenerator,\n    NumberGenerator,\n)\n\n# initialize the generators\nllm_generator = LLMLabelGenerator()\ndate_generator = DateGenerator()\nnumber_generator = NumberGenerator()\n\n# prepare the anonymization mapping\ndef anonymization_mapping(text, entity):\n    if entity.type == \"string\":\n        return llm_generator.generate(entity, temperature=0.7)\n    if entity.label == \"date\":\n        return date_generator.generate(entity, output_gen=\"MIDDLE_OF_THE_MONTH\")\n    if entity.label == \"date of birth\":\n        return date_generator.generate(entity, output_gen=\"MIDDLE_OF_THE_YEAR\")\n    if entity.label == \"social security number\":\n        return number_generator.generate(entity)\n    return \"[REDACTED]\"\n</code></pre> <p>Anonymize the text using the anonymization mapping:</p> <pre><code>from anonipy.anonymize.strategies import PseudonymizationStrategy\n\n# initialize the pseudonymization strategy\npseudo_strategy = PseudonymizationStrategy(mapping=anonymization_mapping)\n\n# anonymize the original text\nanonymized_text, replacements = pseudo_strategy.anonymize(original_text, entities)\n</code></pre>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Anonipy is developed by the Department for Artificial Intelligence at the Jozef Stefan Institute, and other contributors.</p> <p>The project has received funding from the European Union's Horizon Europe research and innovation programme under Grant Agreement No 101080288 (PREPARE).</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#anonipy-050-2025-05-08","title":"anonipy-0.5.0 (2025-05-08)","text":"<p>New Features:</p> <ul> <li>Replace <code>urchade/gliner_multi_pii-v1</code> with <code>E3-JSI/gliner-multi-pii-domains-v1</code> as the main GLiNER extraction model in <code>NERExtractor</code></li> </ul> <p>Bug Fixes:</p> <ul> <li>Fix <code>LANGUAGE.SLOVENE</code> to <code>LANGUAGE.SLOVENIAN</code></li> <li>Fix <code>LanguageDetector</code> when handling <code>LANGUAGE.SLOVENIAN</code></li> <li>Fix unit tests</li> </ul>"},{"location":"changelog/#anonipy-040-2024-12-11","title":"anonipy-0.4.0 (2024-12-11)","text":"<p>New Features:</p> <ul> <li>Add <code>add_generation_prompt</code> to <code>apply_chat_template</code> in <code>LLMLabelGenerator</code></li> <li>Add function to detect repeated entities</li> <li>Add support for generator model quantization in <code>LLMLabelGenerator</code></li> </ul>"},{"location":"changelog/#anonipy-030-2024-12-11","title":"anonipy-0.3.0 (2024-12-11)","text":"<p>New Features:</p> <ul> <li>Add <code>Pipeline</code> module for streamlining text anonymization</li> <li>Add better date handling and support in <code>DateGenerator</code></li> </ul> <p>Bug Fixes:</p> <ul> <li>Fix unit tests</li> <li>Change unit test framework to <code>pytest</code></li> </ul>"},{"location":"changelog/#anonipy-020-2024-11-09","title":"anonipy-0.2.0 (2024-11-09)","text":"<p>Breaking Changes:</p> <ul> <li>Change Python support between v3.9 and v3.12.</li> <li>Change default <code>model_name</code> for <code>LLMLabelGenerator</code> to be <code>HuggingFaceTB/SmolLM2-1.7B-Instruct</code> (for ease of use)</li> </ul> <p>New Features:</p> <ul> <li>Enable CPU utilization for <code>LLMLabelGenerator</code></li> <li>Enable changing the input parameters for <code>LLMLabelGenerator</code> (<code>model_name</code> and <code>use_gpu</code>)</li> <li>Add additional unit tests for <code>NERExtractor</code></li> </ul> <p>Bug Fixes:</p> <ul> <li>Fix package documentation</li> </ul>"},{"location":"changelog/#anonipy-012-2024-07-23","title":"anonipy-0.1.2 (2024-07-23)","text":"<p>Bug Fixes:</p> <ul> <li>Fix entity creation in <code>PatternExtractor</code></li> <li>Fix documentation duplication</li> </ul>"},{"location":"changelog/#anonipy-011-2024-07-16","title":"anonipy-0.1.1 (2024-07-16)","text":"<p>New Features:</p> <ul> <li>Add <code>Entity</code> regex group selection</li> <li>Add option to ignore <code>Entity</code> regex pattern in <code>LLMLabelGenerator.generate</code></li> </ul>"},{"location":"changelog/#anonipy-010-2024-07-16","title":"anonipy-0.1.0 (2024-07-16)","text":"<p>Breaking Changes:</p> <ul> <li>Rename the <code>EntityExtractor</code> to <code>NERExtractor</code></li> <li>Rename the input variable <code>output_gen</code> to <code>sub_variant</code> in <code>DateGenerator</code></li> <li>Rename the input variable <code>entity_prefix</code> to <code>add_entity_attrs</code> in <code>LLMLabelGenerator.generate</code></li> <li>Move the <code>regex</code> submodule from <code>anonipy.anonymize</code> to <code>anonipy.utils</code></li> </ul> <p>New Features:</p> <ul> <li>Add a pattern extractor named <code>PatternExtractor</code>, used to extract entities using spacy pattern matching and regex</li> <li>Add a multi extractor named <code>MultiExtractor</code>, used to extract entities using multiple extractors</li> <li>Add the <code>DATE_TRANSFORM_VARIANTS</code> constant to help with date generator</li> <li>Refine the <code>Entity</code> implementation</li> <li>Improve package documentation</li> </ul>"},{"location":"changelog/#anonipy-008-2024-06-17","title":"anonipy-0.0.8 (2024-06-17)","text":"<p>New Features:</p> <ul> <li>Add automatic date format detection support to <code>DateGenerator</code></li> </ul>"},{"location":"changelog/#anonipy-007-2024-06-06","title":"anonipy-0.0.7 (2024-06-06)","text":"<p>New Features:</p> <ul> <li>Upgrade <code>gliner-spacy</code> to have cleaner code</li> <li>Add function to help manual post-anonymization replacement fixing</li> </ul>"},{"location":"changelog/#anonipy-006-2024-05-31","title":"anonipy-0.0.6 (2024-05-31)","text":"<p>New Features:</p> <ul> <li>Add GPU support and entity scores to <code>EntityExtractor</code></li> <li>Standardize the function naming in strategies</li> </ul>"},{"location":"changelog/#anonipy-005-2024-05-29","title":"anonipy-0.0.5 (2024-05-29)","text":"<p>New Features:</p> <ul> <li>Re-implement file reading methods + add unit tests</li> <li>Expland the test environment on all OS</li> </ul>"},{"location":"changelog/#anonipy-004-2024-05-27","title":"anonipy-0.0.4 (2024-05-27)","text":"<p>New Features:</p> <ul> <li>Add unit tests</li> <li>Refine the Entity implementation</li> <li>Update documentation</li> </ul> <p>Bug Fixes:</p> <ul> <li>Fix the <code>LANGUAGES</code> constant</li> </ul>"},{"location":"changelog/#anonipy-003-2024-05-22","title":"anonipy-0.0.3 (2024-05-22)","text":"<p>New features:</p> <ul> <li>Add <code>read_json</code> function</li> <li>Add <code>write_json</code> function</li> <li>Add blog post on anonymizing collections of documents</li> <li>Reduce the number of viable suggestions used to create a substitute in <code>MaskLabelGenerator</code></li> <li>Add the entity label to the replacements in strategies</li> </ul> <p>Bug Fixes:</p> <ul> <li>Fix the entity regex checking in <code>EntityExtractor</code></li> </ul>"},{"location":"changelog/#anonipy-002-2024-05-22","title":"anonipy-0.0.2 (2024-05-22)","text":"<p>New Features:</p> <ul> <li>Add <code>write_file</code> function</li> <li>Add blog to the documentation</li> </ul>"},{"location":"changelog/#anonipy-001-2024-05-21","title":"anonipy-0.0.1 (2024-05-21)","text":"<ul> <li>Initial release</li> </ul>"},{"location":"development/","title":"Development","text":"<p>This section is for developers only. It describes the requirements, the setup process, how to run tests, and how to deploy.</p>"},{"location":"development/#requirements","title":"Requirements","text":"<p>Before starting the project make sure these requirements are available:</p> <ul> <li> <p>python. The python programming language (v3.9, v3.10, v3.11, v3.12).</p> </li> <li> <p>git. For versioning your code.</p> </li> </ul>"},{"location":"development/#setup","title":"Setup","text":""},{"location":"development/#create-the-python-environment","title":"Create the python environment","text":"<p>To create a python virtual environment using <code>venv</code>, simply run the following commands:</p> <pre><code># create a new virtual environment\npython -m venv venv\n\n# activate the environment (UNIX)\n. ./venv/bin/activate\n\n# activate the environment (WINDOWS)\n./venv/Scripts/activate\n\n# deactivate the environment (UNIX &amp; WINDOWS)\ndeactivate\n</code></pre>"},{"location":"development/#install","title":"Install","text":"<p>To install the requirements run:</p> <pre><code>pip install -e .[all]\n</code></pre> <p>Githooks. Githooks enable automatic commit and push hooks. The project is configured to run tests on each commit and to run tests and format the code on each push. See the configuration in <code>.githooks.ini</code>. To enable git hooks, run:</p> <pre><code>githooks\n</code></pre>"},{"location":"development/#tests","title":"Tests","text":"<p>To run existing tests, simply run:</p> <pre><code>pytest\n</code></pre>"},{"location":"development/#documentation","title":"Documentation","text":"<p>To start live-reloading the documentation, run:</p> <pre><code>mkdocs serve\n</code></pre> <p>When suggesting changes, please refer to the Material for MkDocs documentation.</p>"},{"location":"development/#deployment","title":"Deployment","text":"<p>Once the changes are accepted into the project, the GitHub Actions automatically deploy the documentation to the <code>gh-pages</code> branch.</p>"},{"location":"how-to-guides/","title":"How-To Guides","text":""},{"location":"how-to-guides/2024/07/16/anonymizing-collections-of-documents/","title":"Anonymizing collections of documents","text":"<p>In the previous blog post, we showed how one can anonymize text in document form. While the code is useful for processing a single document, anonymizing a collection of documents can take time if we run the script for each document separately.</p> <p>In this blog post, we show how one can anonymize collections of documents. The process is similar to the previous blog post, but loads all required components only once, and anonymizes all documents in one go.</p> <p>Prerequisites</p> <p>To use the <code>anonipy</code> package, we must have Python version 3.8 or higher installed on the machine.</p>"},{"location":"how-to-guides/2024/07/16/anonymizing-collections-of-documents/#installation","title":"Installation","text":"<p>Before we start, we must first install the <code>anonipy</code> package. To do that, run the following command in the terminal:</p> <pre><code>pip install anonipy\n</code></pre> <p>This will install the <code>anonipy</code> package, which contains all of the required modules.</p> <p>If you already installed it and would like to update it, run the following command:</p> <pre><code>pip install anonipy --upgrade\n</code></pre>"},{"location":"how-to-guides/2024/07/16/anonymizing-collections-of-documents/#preparing-the-components","title":"Preparing the components","text":"<p>First, let us prepare all of the components for the anonymization process. It consists of preparing the entity extractor, the anonymization strategy, and the generators for the anonymization process.</p> <pre><code>from anonipy.anonymize.extractors import NERExtractor\nfrom anonipy.anonymize.generators import (\n    MaskLabelGenerator,\n    DateGenerator,\n    NumberGenerator,\n)\nfrom anonipy.anonymize.strategies import PseudonymizationStrategy\nfrom anonipy.constants import LANGUAGES\n\n# =====================================\n# Prepare the entity extractor\n# =====================================\n\n# define the labels to be extracted and their types\nlabels = [\n    {\"label\": \"name\", \"type\": \"string\"},\n    {\"label\": \"social security number\", \"type\": \"custom\"},\n    {\"label\": \"date of birth\", \"type\": \"date\"},\n    {\"label\": \"date\", \"type\": \"date\"},\n]\n\n# initialize the entity extractor\nentity_extractor = NERExtractor(\n    labels, lang=LANGUAGES.ENGLISH, score_th=0.5\n)\n\n# =====================================\n# Prepare the anonymization strategy\n# =====================================\n\n# initialize the generators\nmask_generator = MaskLabelGenerator()\ndate_generator = DateGenerator()\nnumber_generator = NumberGenerator()\n\n# prepare the anonymization mapping\ndef anonymization_mapping(text, entity):\n    if entity.type == \"string\":\n        return mask_generator.generate(entity, text)\n    if entity.label == \"date\":\n        return date_generator.generate(entity, sub_variant=\"MIDDLE_OF_THE_MONTH\")\n    if entity.label == \"date of birth\":\n        return date_generator.generate(entity, sub_variant=\"MIDDLE_OF_THE_YEAR\")\n    if entity.label == \"social security number\":\n        return number_generator.generate(entity)\n    return \"[REDACTED]\"\n\n# initialize the pseudonymization strategy\npseudo_strategy = PseudonymizationStrategy(mapping=anonymization_mapping)\n</code></pre>"},{"location":"how-to-guides/2024/07/16/anonymizing-collections-of-documents/#anonymizing-the-collection-of-documents","title":"Anonymizing the collection of documents","text":"<p>Now, let us anonymize all of the documents in the collection. We first prepare a folder containing the documents, that we want to anonymize. The path to the folder will be available via the <code>input_folder</code> variable.</p> <p>We will, one-by-one, read all of the documents in the folder, extract the text from each document, and anonymize the text.</p> <p>Finally, we will store the anonymized text in another folder. The path to the folder will be available via the <code>output_folder</code> variable.</p> <pre><code>import os\nfrom os.path import isfile, join\nfrom anonipy.utils.file_system import open_file, write_file, write_json\n\n# prepare the input and output folder paths\ninput_folder = \"path/to/input/folder\"\noutput_folder = \"path/to/output/folder\"\n\n# prepare a list of file paths in the input folder\nfile_names = [\n    f for f in os.listdir(input_folder) if isfile(join(input_folder, f))\n]\n\n# iterate through each file\nfor file_name in file_names:\n\n    # extract the text from the document\n    file_text = open_file(join(input_folder, file_name))\n\n    # extract the entities from the text\n    doc, entities = entity_extractor(file_text)\n\n    # anonymize the text\n    anonymized_text, replacements = pseudo_strategy.anonymize(file_text, entities)\n\n    # write the anonymized text into the output folder\n    output_file_name = \".\".join(file_name.split(\".\")[:-1]) + \"_anonymized\"\n    write_file(anonymized_text, join(output_folder, output_file_name) + \".txt\")\n\n    # write the replacements into the output folder\n    write_json(replacements, join(output_folder, output_file_name) + \".json\")\n</code></pre> <p>Given the above code, we can anonymize all of the documents in the collection without loading and preparing the extractor, generators and strategy every time.</p>"},{"location":"how-to-guides/2024/07/16/anonymizing-collections-of-documents/#conclusion","title":"Conclusion","text":"<p>In this blog post, we show how one can anonymize collections of documents in out go using the <code>anonipy</code> package. We first prepare the components for the anonymization process. We then find all of the files we want to anonymize and anonymize them. Each anonymized file is finally stored in a separate folder which contains the anonymized text.</p>"},{"location":"how-to-guides/2024/07/16/anonymizing-collections-of-documents/#full-code","title":"Full code","text":"<pre><code>import os\nfrom os.path import isfile, join\n\nfrom anonipy.anonymize.extractors import NERExtractor\nfrom anonipy.anonymize.generators import (\n    MaskLabelGenerator,\n    DateGenerator,\n    NumberGenerator,\n)\nfrom anonipy.anonymize.strategies import PseudonymizationStrategy\nfrom anonipy.utils.file_system import open_file, write_file, write_json\nfrom anonipy.constants import LANGUAGES\n\n# ===============================================\n# Preparing the anonymization components\n# ===============================================\n\n# define the labels to be extracted and their types\nlabels = [\n    {\"label\": \"name\", \"type\": \"string\"},\n    {\"label\": \"social security number\", \"type\": \"custom\"},\n    {\"label\": \"date of birth\", \"type\": \"date\"},\n    {\"label\": \"date\", \"type\": \"date\"},\n]\n\n# initialize the entity extractor\nentity_extractor = NERExtractor(\n    labels, lang=LANGUAGES.ENGLISH, score_th=0.5\n)\n\n# initialize the generators\nmask_generator = MaskLabelGenerator()\ndate_generator = DateGenerator()\nnumber_generator = NumberGenerator()\n\n# prepare the anonymization mapping\ndef anonymization_mapping(text, entity):\n    if entity.type == \"string\":\n        return mask_generator.generate(entity, text)\n    if entity.label == \"date\":\n        return date_generator.generate(entity, sub_variant=\"MIDDLE_OF_THE_MONTH\")\n    if entity.label == \"date of birth\":\n        return date_generator.generate(entity, sub_variant=\"MIDDLE_OF_THE_YEAR\")\n    if entity.label == \"social security number\":\n        return number_generator.generate(entity)\n    return \"[REDACTED]\"\n\n# initialize the pseudonymization strategy\npseudo_strategy = PseudonymizationStrategy(mapping=anonymization_mapping)\n\n# ===============================================\n# Anonymize the collection of documents\n# ===============================================\n\n# prepare the input and output folder paths\ninput_folder = \"path/to/input/folder\"\noutput_folder = \"path/to/output/folder\"\n\n# prepare a list of file paths in the input folder\nfile_names = [\n    f for f in os.listdir(input_folder) if isfile(join(input_folder, f))\n]\n\n# iterate through each file\nfor file_name in file_names:\n\n    # extract the text from the document\n    file_text = open_file(join(input_folder, file_name))\n\n    # extract the entities from the text\n    doc, entities = entity_extractor(file_text)\n\n    # anonymize the text\n    anonymized_text, replacements = pseudo_strategy.anonymize(file_text, entities)\n\n    # write the anonymized text into the output folder\n    output_file_name = \".\".join(file_name.split(\".\")[:-1]) + \"_anonymized\"\n    write_file(anonymized_text, join(output_folder, output_file_name) + \".txt\")\n\n    # write the replacements into the output folder\n    write_json(replacements, join(output_folder, output_file_name) + \".json\")\n</code></pre>"},{"location":"how-to-guides/2024/07/16/anonymizing-documents/","title":"Anonymizing documents","text":"<p>The anonipy package was designed for anonymizing text. However, a lot of text data can be found in document form, such as PDFs, word documents, and other. Copying the text from the documents  to be anonymized can be cumbersome. The <code>anonipy</code> package provides utility functions that extracts the text from the documents.</p> <p>In this blog post, we explain how <code>anonipy</code> can be used to anonymize texts in document form.</p> <p>Prerequisites</p> <p>To use the <code>anonipy</code> package, we must have Python version 3.8 or higher installed on the machine.</p>"},{"location":"how-to-guides/2024/07/16/anonymizing-documents/#installation","title":"Installation","text":"<p>Before we start, we must first install the <code>anonipy</code> package. To do that, run the following command in the terminal:</p> <pre><code>pip install anonipy\n</code></pre> <p>This will install the <code>anonipy</code> package, which contains all of the required modules.</p> <p>If you already installed it and would like to update it, run the following command:</p> <pre><code>pip install anonipy --upgrade\n</code></pre>"},{"location":"how-to-guides/2024/07/16/anonymizing-documents/#document-anonymization","title":"Document anonymization","text":""},{"location":"how-to-guides/2024/07/16/anonymizing-documents/#extracting-the-text-from-the-document","title":"Extracting the text from the document","text":"<p>Next, we will use the <code>anonipy</code> package to anonymize the text in the document. First, we must extract the text. This can be done using the package's utility function open_file. The function supports extraction of text from <code>doc</code>, <code>docx</code>, <code>pdf</code> and <code>txt</code> files.</p> <p>To extract the text, using the following code:</p> <pre><code>from anonipy.utils.file_system import open_file\n\nfile_path = \"path/to/file.txt\"\nfile_text = open_file(file_path)\n</code></pre> <p>where <code>file_path</code> is the path to the document we want to anonymize. The open_file will open the document, extract the content, and return it as a string.</p> <p>Once this is done, we can start anonymizing the text, in a regular way.</p>"},{"location":"how-to-guides/2024/07/16/anonymizing-documents/#extracting-personal-information-from-the-text","title":"Extracting personal information from the text","text":"<p>Now we can identify and extract personal information from the text. We do this by using NERExtractor, an extractor that leverages the GLiNER span-based NER models.</p> <p>It returns the text and the extracted entities.</p> <pre><code>from anonipy.constants import LANGUAGES\nfrom anonipy.anonymize.extractors import NERExtractor\n\n# define the labels to be extracted and their types\nlabels = [\n    {\"label\": \"name\", \"type\": \"string\"},\n    {\"label\": \"social security number\", \"type\": \"custom\"},\n    {\"label\": \"date of birth\", \"type\": \"date\"},\n    {\"label\": \"date\", \"type\": \"date\"},\n]\n\n# initialize the entity extractor\nextractor = NERExtractor(\n    labels, lang=LANGUAGES.ENGLISH, score_th=0.5\n)\n# extract the entities from the original text\ndoc, entities = extractor(file_text)\n</code></pre> <p>To display the entities in the original text, we can use the  display method:</p> <pre><code>extractor.display(doc)\n</code></pre>"},{"location":"how-to-guides/2024/07/16/anonymizing-documents/#preparing-the-anonymization-mapping","title":"Preparing the anonymization mapping","text":"<p>Next, we prepare the anonymization mapping. We do this by using the generators module part of the <code>anonipy</code> package. The generators are used to generate substitutes for the entities.</p> <p>For example, we can use MaskLabelGenerator to generate substitutes using the language models to solve a <code>mask-filling</code> problem, i.e. finding the words that would be probabilistically suitable to replace the entity in the text.</p> <p>The full list of available generators can be found in the generators submodule.</p> <p>Furthermore, we use the PseudonymizationStrategy to anonymize the text. More on anonymization strategies can be found in the strategies submodule.</p> <pre><code>from anonipy.anonymize.generators import (\n    MaskLabelGenerator,\n    DateGenerator,\n    NumberGenerator,\n)\nfrom anonipy.anonymize.strategies import PseudonymizationStrategy\n\n# initialize the generators\nmask_generator = MaskLabelGenerator()\ndate_generator = DateGenerator()\nnumber_generator = NumberGenerator()\n\n# prepare the anonymization mapping\ndef anonymization_mapping(text, entity):\n    if entity.type == \"string\":\n        return mask_generator.generate(entity, text)\n    if entity.label == \"date\":\n        return date_generator.generate(entity, sub_variant=\"MIDDLE_OF_THE_MONTH\")\n    if entity.label == \"date of birth\":\n        return date_generator.generate(entity, sub_variant=\"MIDDLE_OF_THE_YEAR\")\n    if entity.label == \"social security number\":\n        return number_generator.generate(entity)\n    return \"[REDACTED]\"\n\n# initialize the pseudonymization strategy\npseudo_strategy = PseudonymizationStrategy(mapping=anonymization_mapping)\n</code></pre>"},{"location":"how-to-guides/2024/07/16/anonymizing-documents/#anonymizing-the-text","title":"Anonymizing the text","text":"<p>Once we prepare the anonymization strategy, we can use it to anonymize the text.</p> <pre><code># anonymize the original text\nanonymized_text, replacements = pseudo_strategy.anonymize(file_text, entities)\n</code></pre>"},{"location":"how-to-guides/2024/07/16/anonymizing-documents/#saving-the-anonymized-text","title":"Saving the anonymized text","text":"<p>Finally, we can save the anonymized text to a file. This can be done using the write_file function from the file_system submodule.</p> <pre><code>from anonipy.utils.file_system import write_file\n\noutput_file = \"path/to/output_file.txt\"\nwrite_file(anonymized_text, output_file, encode=\"utf-8\")\n</code></pre> <p>Where <code>output_file</code> is the path to the file where the anonymized text will be saved.</p>"},{"location":"how-to-guides/2024/07/16/anonymizing-documents/#conclusion","title":"Conclusion","text":"<p>In this blog post, we show how one can anonymize a document using the <code>anonipy</code> package. We first used the open_file utility function to extract the content of the document and store it as a string. We then used the NERExtractor to identify and extract personal information form the text, and the PseudonymizationStrategy in combination with various generators to anonymize the text. Finally, we used the write_file utility function to save the anonymized text to a file.</p> <p>This process is very straightforward and can be applied to almost any document type. Furthermore, it can be expanded to process multiple documents written in the same language at once. Stay tuned to see how this can be done in the future!</p>"},{"location":"how-to-guides/2024/07/16/anonymizing-documents/#full-code","title":"Full code","text":"<pre><code>from anonipy.anonymize.extractors import NERExtractor\nfrom anonipy.anonymize.generators import (\n    MaskLabelGenerator,\n    DateGenerator,\n    NumberGenerator,\n)\nfrom anonipy.anonymize.strategies import PseudonymizationStrategy\n\nfrom anonipy.utils.file_system import open_file, write_file\nfrom anonipy.constants import LANGUAGES\n\n# =====================================\n# Read the file content\n# =====================================\n\n# load the file content\nfile_path = \"path/to/file.txt\"\nfile_text = open_file(file_path)\n\n# =====================================\n# Extract the entities\n# =====================================\n\n# define the labels to be extracted and their types\nlabels = [\n    {\"label\": \"name\", \"type\": \"string\"},\n    {\"label\": \"social security number\", \"type\": \"custom\"},\n    {\"label\": \"date of birth\", \"type\": \"date\"},\n    {\"label\": \"date\", \"type\": \"date\"},\n]\n\n# initialize the entity extractor\nextractor = NERExtractor(\n    labels, lang=LANGUAGES.ENGLISH, score_th=0.5\n)\n\n# extract the entities from the original text\ndoc, entities = extractor(file_text)\n\n# =====================================\n# Prepare the anonymization strategy\n#   and anonymize the text\n# =====================================\n\n# initialize the generators\nmask_generator = MaskLabelGenerator()\ndate_generator = DateGenerator()\nnumber_generator = NumberGenerator()\n\n# prepare the anonymization mapping\ndef anonymization_mapping(text, entity):\n    if entity.type == \"string\":\n        return mask_generator.generate(entity, text)\n    if entity.label == \"date\":\n        return date_generator.generate(entity, sub_variant=\"MIDDLE_OF_THE_MONTH\")\n    if entity.label == \"date of birth\":\n        return date_generator.generate(entity, sub_variant=\"MIDDLE_OF_THE_YEAR\")\n    if entity.label == \"social security number\":\n        return number_generator.generate(entity)\n    return \"[REDACTED]\"\n\n# initialize the pseudonymization strategy\npseudo_strategy = PseudonymizationStrategy(mapping=anonymization_mapping)\n\n# anonymize the original text\nanonymized_text, replacements = pseudo_strategy.anonymize(file_text, entities)\n\n# =====================================\n# Save the anonymized text\n# =====================================\n\n# save the anonymized text to a file\noutput_file = \"path/to/output_file.txt\"\nwrite_file(anonymized_text, output_file, encode=\"utf-8\")\n</code></pre>"},{"location":"how-to-guides/2024/12/11/document-anonymization-using-pipeline/","title":"Document anonymization using pipeline","text":"<p>In this blog post, we show how one can anonymize documents using the new <code>Pipeline</code> module. The module allows for a streamlined process of anonymizing documents, where the user defines how the anonymization should be performed and the locations, where the documents to be anonymized are located and where the anonymized documents should be stored.</p> <p>The pipeline will automatically extract the text from the documents, anonymize the text, and store the anonymized text in the output folder.</p> <p>Prerequisites</p> <p>To use the <code>anonipy</code> package, we must have Python version 3.8 or higher installed on the machine.</p>"},{"location":"how-to-guides/2024/12/11/document-anonymization-using-pipeline/#installation","title":"Installation","text":"<p>Before we start, we must first install the <code>anonipy</code> package. To do that, run the following command in the terminal:</p> <pre><code>pip install anonipy\n</code></pre> <p>This will install the <code>anonipy</code> package, which contains all of the required modules.</p> <p>If you already installed it and would like to update it, run the following command:</p> <pre><code>pip install anonipy --upgrade\n</code></pre>"},{"location":"how-to-guides/2024/12/11/document-anonymization-using-pipeline/#preparing-the-components","title":"Preparing the components","text":"<p>First, let us prepare all of the components for the anonymization process. It consists of preparing the entity extractor, the anonymization strategy, and the generators for the anonymization process.</p> <pre><code>from anonipy.anonymize.extractors import NERExtractor\nfrom anonipy.anonymize.generators import (\n    LLMLabelGenerator,\n    DateGenerator,\n    NumberGenerator,\n)\nfrom anonipy.anonymize.strategies import PseudonymizationStrategy\nfrom anonipy.constants import LANGUAGES\n\n# =====================================\n# Prepare the entity extractors\n# =====================================\n\n# define the NER labels to be extracted and their types\nlabels = [\n    {\"label\": \"name\", \"type\": \"string\"},\n    {\"label\": \"social security number\", \"type\": \"custom\"},\n    {\"label\": \"date of birth\", \"type\": \"date\"},\n    {\"label\": \"date\", \"type\": \"date\"},\n]\n\n# initialize the extractor\nextractor = NERExtractor(\n    labels, lang=LANGUAGES.ENGLISH, score_th=0.5\n)\n\n# =====================================\n# Prepare the anonymization strategy\n# =====================================\n\n# initialize the generators\nllm_generator = LLMLabelGenerator()\ndate_generator = DateGenerator()\nnumber_generator = NumberGenerator()\n\n# prepare the anonymization mapping\ndef anonymization_mapping(text, entity):\n    if entity.type == \"string\":\n        return llm_generator.generate(entity, text)\n    if entity.label == \"date\":\n        return date_generator.generate(entity, sub_variant=\"MIDDLE_OF_THE_MONTH\")\n    if entity.label == \"date of birth\":\n        return date_generator.generate(entity, sub_variant=\"MIDDLE_OF_THE_YEAR\")\n    if entity.label == \"social security number\":\n        return number_generator.generate(entity)\n    return \"[REDACTED]\"\n\n# initialize the pseudonymization strategy\nstrategy = PseudonymizationStrategy(mapping=anonymization_mapping)\n</code></pre>"},{"location":"how-to-guides/2024/12/11/document-anonymization-using-pipeline/#anonymizing-the-documents-using-the-pipeline","title":"Anonymizing the documents using the pipeline","text":"<p>Now, let prepare the pipeline for anonymizing the documents. The pipeline is available in the [anonipy.anonymize.pipeline] module. We will use the pipeline to anonymize all of the documents in a folder.</p> <pre><code>from anonipy.anonymize.pipeline import Pipeline\n\npipeline = Pipeline(extractor, strategy)\n</code></pre> <p>Let us now assume that the documents are stored in a folder called <code>path/to/input/folder</code>. We want to anonymize all of the documents in the folder and store the anonymized documents in another folder called <code>path/to/output/folder</code>.</p> <pre><code>input_folder = \"path/to/input/folder\"\noutput_folder = \"path/to/output/folder\"\nfile_mapping = pipeline.anonymize(input_folder, output_folder, flatten=True)# (1)!\n</code></pre> <ol> <li>The <code>flatten</code> parameter specifies whether the pipeline should flatten the    output folder structure. If <code>True</code>, the pipeline will store all of the anonymized    documents in the output folder. If <code>False</code>, the pipeline will store the anonymized    documents in the same folder structure as the input folder.</li> </ol> <p>The <code>anonymize</code> method will extract the text from each document in the input folder and subfolders, anonymize the text, and store the anonymized text in the output folder. The method returns a dictionary where the keys are the file paths of the original documents and the values are the file paths of the anonymized documents.</p>"},{"location":"how-to-guides/2024/12/11/document-anonymization-using-pipeline/#conclusion","title":"Conclusion","text":"<p>In this blog post, we show how one can anonymize collections of documents using the new <code>Pipeline</code> class. We first prepare the entity extractor, the anonymization strategy, and the generators for the anonymization process. After that, we initialize the <code>Pipeline</code> class and use it to anonymize all of the documents in the input folder, and store the anonymized documents in the output folder.</p>"},{"location":"how-to-guides/2024/12/11/document-anonymization-using-pipeline/#full-code","title":"Full code","text":"<pre><code>from anonipy.anonymize.extractors import NERExtractor\nfrom anonipy.anonymize.generators import (\n    LLMLabelGenerator,\n    DateGenerator,\n    NumberGenerator,\n)\nfrom anonipy.anonymize.strategies import PseudonymizationStrategy\nfrom anonipy.anonymize.pipeline import Pipeline\nfrom anonipy.constants import LANGUAGES\n\n# =====================================\n# Prepare the entity extractors\n# =====================================\n\n# define the NER labels to be extracted and their types\nlabels = [\n    {\"label\": \"name\", \"type\": \"string\"},\n    {\"label\": \"social security number\", \"type\": \"custom\"},\n    {\"label\": \"date of birth\", \"type\": \"date\"},\n    {\"label\": \"date\", \"type\": \"date\"},\n]\n\n# initialize the extractor\nextractor = NERExtractor(\n    labels, lang=LANGUAGES.ENGLISH, score_th=0.5\n)\n\n# =====================================\n# Prepare the anonymization strategy\n# =====================================\n\n# initialize the generators\nllm_generator = LLMLabelGenerator()\ndate_generator = DateGenerator()\nnumber_generator = NumberGenerator()\n\n# prepare the anonymization mapping\ndef anonymization_mapping(text, entity):\n    if entity.type == \"string\":\n        return llm_generator.generate(entity, text)\n    if entity.label == \"date\":\n        return date_generator.generate(entity, sub_variant=\"MIDDLE_OF_THE_MONTH\")\n    if entity.label == \"date of birth\":\n        return date_generator.generate(entity, sub_variant=\"MIDDLE_OF_THE_YEAR\")\n    if entity.label == \"social security number\":\n        return number_generator.generate(entity)\n    return \"[REDACTED]\"\n\n# initialize the pseudonymization strategy\nstrategy = PseudonymizationStrategy(mapping=anonymization_mapping)\n\n# ===============================================\n# Initialize the pipeline\n# ===============================================\n\npipeline = Pipeline(extractor, strategy)\n\n# ===============================================\n# Anonymize the documents\n# ===============================================\n\ninput_folder = \"path/to/input/folder\"\noutput_folder = \"path/to/output/folder\"\nfile_mapping = pipeline.anonymize(input_folder, output_folder, flatten=True)\n</code></pre>"},{"location":"how-to-guides/2024/07/15/extractors-overview/","title":"Extractors overview","text":"<p>In this post, we will show an overview of the implemented extractors. The extractors are used to extract relevant <code>named entities</code> from text. These entities can be people names, organizations, addresses, social security numbers, etc. The entities are then used to anonymize the text.</p> <p>All extractors and their API references are available in the  extractors module. What follows is the presentation of the different extractors <code>anonipy</code> provides.</p>"},{"location":"how-to-guides/2024/07/15/extractors-overview/#pre-requisites","title":"Pre-requisites","text":"<p>Let us first define the text, from which we want to extract the entities.</p> <pre><code>original_text = \"\"\"\\\nMedical Record\n\nPatient Name: John Doe\nDate of Birth: 15-01-1985\nDate of Examination: 20-05-2024\nSocial Security Number: 123-45-6789\n\nExamination Procedure:\nJohn Doe underwent a routine physical examination. The procedure included measuring vital signs (blood pressure, heart rate, temperature), a comprehensive blood panel, and a cardiovascular stress test. The patient also reported occasional headaches and dizziness, prompting a neurological assessment and an MRI scan to rule out any underlying issues.\n\nMedication Prescribed:\n\nIbuprofen 200 mg: Take one tablet every 6-8 hours as needed for headache and pain relief.\nLisinopril 10 mg: Take one tablet daily to manage high blood pressure.\nNext Examination Date:\n15-11-2024\n\"\"\"\n</code></pre>"},{"location":"how-to-guides/2024/07/15/extractors-overview/#language-configuration","title":"Language configuration","text":"<p>Each extractor requires a language to be configured. The language is used to determine how to process the text. If the language is not specified, the extractor will use the default language. The default language is <code>ENGLISH</code>.</p> <p>To make it easier to switch languages, we can use the LANGUAGES constant.</p> <pre><code>from anonipy.constants import LANGUAGES\n\nLANGUAGE.ENGLISH# (1)!\n</code></pre> <ol> <li>The <code>LANGUAGE.ENGLISH</code> return the <code>(\"en\", \"English\")</code> literal tuple, which is the format required by the extractors.</li> </ol>"},{"location":"how-to-guides/2024/07/15/extractors-overview/#using-the-language-detector","title":"Using the language detector","text":"<p>An alternative is to use a language detector available in the language_detector module. The detector utilizes the lingua python package, and allows automatic detection of the language of the text.</p> <pre><code>from anonipy.utils.language_detector import LanguageDetector\n\n# initialize the language detector and detect the language\nlanguage_detector = LanguageDetector()\nlanguage_detector(original_text)# (1)!\n</code></pre> <ol> <li>The <code>language_detector</code> returns the literal tuple <code>(\"en\", \"English\")</code>, similar to the <code>LANGUAGE.ENGLISH</code>, making it compatible with the extractors.</li> </ol>"},{"location":"how-to-guides/2024/07/15/extractors-overview/#named-entity","title":"Named Entity","text":"<p>Each extractor will extract the <code>named entities</code> from the text. The entities can be people names, organizations, addresses, social security numbers, etc. The entities are represented using the Entity dataclass, which consists of the following parameters:</p> <p>Attributes:</p> Name Type Description <code>text</code> <code>str</code> <p>The text of the entity.</p> <code>label</code> <code>str</code> <p>The label of the entity.</p> <code>start_index</code> <code>int</code> <p>The start index of the entity in the text.</p> <code>end_index</code> <code>int</code> <p>The end index of the entity in the text.</p> <code>score</code> <code>float</code> <p>The prediction score of the entity. The score is returned by the extractor models.</p> <code>type</code> <code>ENTITY_TYPES</code> <p>The type of the entity.</p> <code>regex</code> <code>Union[str, Pattern]</code> <p>The regular expression the entity must match.</p>"},{"location":"how-to-guides/2024/07/15/extractors-overview/#anonipy.definitions.Entity.get_regex_group","title":"<code>get_regex_group()</code>","text":"<p>Returns:</p> Type Description <code>Union[str, None]</code> <p>The regex group.</p>"},{"location":"how-to-guides/2024/07/15/extractors-overview/#anonipy.definitions.Entity.__str__","title":"<code>__str__()</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>The string representation of the entity.</p>"},{"location":"how-to-guides/2024/07/15/extractors-overview/#extractors","title":"Extractors","text":"<p>All following extractors are available in the extractors module.</p>"},{"location":"how-to-guides/2024/07/15/extractors-overview/#named-entity-recognition-ner-extractor","title":"Named entity recognition (NER) extractor","text":"<p>The NERExtractor extractor uses a span-based NER model to identify the relevant entities in the text. Furthermore, it uses the GLiNER span-based NER model, specifically the model finetuned for recognizing Personal Identifiable Information (PII) within text. The model has been finetuned on six languages (English, French, German, Spanish, Italian, and Portuguese), but can be applied also to other languages.</p> <pre><code>from anonipy.anonymize.extractors import NERExtractor\n</code></pre> <p>The <code>NERExtractor</code> takes the following input parameters:</p> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>List[dict]</code> <p>The list of labels to extract.</p> required <code>lang</code> <code>LANGUAGES</code> <p>The language of the text to extract.</p> <code>ENGLISH</code> <code>score_th</code> <code>float</code> <p>The score threshold. Entities with a score below this threshold will be ignored.</p> <code>0.5</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use GPU.</p> <code>False</code> <code>gliner_model</code> <code>str</code> <p>The gliner model to use to identify the entities.</p> <code>'E3-JSI/gliner-multi-pii-domains-v1'</code> <code>spacy_style</code> <code>str</code> <p>The style the entities should be stored in the spacy doc. Options: <code>ent</code> or <code>span</code>.</p> <code>'ent'</code> <p>We must define the labels to be extracted and their types. In this example, we will extract the following entities:</p> <pre><code>labels = [\n    {\"label\": \"name\", \"type\": \"string\"},\n    {\"label\": \"social security number\", \"type\": \"custom\", \"regex\": \"[0-9]{3}-[0-9]{2}-[0-9]{4}\"},\n    {\"label\": \"date of birth\", \"type\": \"date\"},\n    {\"label\": \"date\", \"type\": \"date\"},\n]\n</code></pre> <p>Let us now initialize the entity extractor.</p> <pre><code>ner_extractor = NERExtractor(labels, lang=LANGUAGES.ENGLISH, score_th=0.5)\n</code></pre> <p>Initialization warnings</p> <p>The initialization of <code>NERExtractor</code> will throw some warnings. Ignore them. These are expected due to the use of package dependencies.</p> <p>The <code>NERExtractor</code> receives the text to be anonymized and returns the enriched text document and the extracted entities.</p> <pre><code>doc, entities = ner_extractor(original_text)\n</code></pre> <p>The entities extracted within the input text are:</p> <pre><code>ner_extractor.display(doc)\n</code></pre> Medical RecordPatient Name:              John Doe         name Date of Birth:              15-01-1985         date             of birth Date of Examination:              20-05-2024         date Social Security Number:              123-45-6789         social             security number Examination Procedure:          John Doe         name      underwent a routine physical examination. The procedure included measuring vital signs (blood pressure, heart     rate, temperature), a comprehensive blood panel, and a cardiovascular stress test. The patient also reported     occasional headaches and dizziness, prompting a neurological assessment and an MRI scan to rule out any     underlying issues.Medication Prescribed:Ibuprofen 200 mg: Take one tablet every 6-8 hours as     needed for headache and pain relief.Lisinopril 10 mg: Take one tablet daily to manage high blood     pressure.Next Examination Date:          15-11-2024         date <p>Advices and suggestions</p> <p>Use specific label names. In the above example, we used specific label names to extract the entities. If we use a less specific name, the entity extractor might not find any relevant entity.</p> <p>For instance, when using <code>social security number</code> as the label name, the entity extractor is able to extract the social security number from the text. However, if we use <code>ssn</code> or just <code>number</code> as the label name, the entity extractor might not find any relevant entity.</p> <p>Tip</p> <p>Using more specific label names is better.</p> <p>Use custom regex patterns. In the <code>anonipy</code> package, we provide some predefined ENTITY_TYPES, which are:</p> <p>Attributes:</p> Name Type Description <code>CUSTOM</code> <code>Literal[custom]</code> <p>The custom entity type.</p> <code>STRING</code> <code>Literal[string]</code> <p>The string entity type.</p> <code>INTEGER</code> <code>Literal[integer]</code> <p>The integer entity type.</p> <code>FLOAT</code> <code>Literal[float]</code> <p>The float entity type.</p> <code>DATE</code> <code>Literal[date]</code> <p>The date entity type.</p> <code>EMAIL</code> <code>Literal[email]</code> <p>The email entity type.</p> <code>WEBSITE_URL</code> <code>Literal[website_url]</code> <p>The website url entity type.</p> <code>PHONE_NUMBER</code> <code>Literal[phone_number]</code> <p>The phone number entity type.</p> <p>These entity types also have a corresponding regex pattern, as defined in the regex submodule.</p> <p>If the user wants to use a custom regex pattern, they can define it in the <code>labels</code>  variable list. Using a custom regex pattern allows the user to specify a more strict pattern that the entity must match.</p>"},{"location":"how-to-guides/2024/07/15/extractors-overview/#pattern-extractor","title":"Pattern extractor","text":"<p>The PatternExtractor is an extractor that uses a custom spacy and regex pattern to extract entities. When documents have a consistent format and structure, the pattern extractor can be useful, as it can extract entities in a consistent way.</p> <pre><code>from anonipy.anonymize.extractors import PatternExtractor\n</code></pre> <p>The <code>PatternExtractor</code> takes the following parameters:</p> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>List[dict]</code> <p>The list of labels and patterns to extract.</p> required <code>lang</code> <code>LANGUAGES</code> <p>The language of the text to extract.</p> <code>ENGLISH</code> <code>spacy_style</code> <code>str</code> <p>The style the entities should be stored in the spacy doc. Options: <code>ent</code> or <code>span</code>.</p> <code>'ent'</code> <p>We must define the labels and their patterns used to extract the relevant entities. The patterns are defined using spacy patterns or regex patterns.</p> <p>In this example, we will use the following labels and patterns:</p> <pre><code>labels = [\n    # the pattern is defined using regex patterns, where the paranthesis are used to indicate core entity values\n    {\"label\": \"symptoms\", \"regex\": r\"\\((.*)\\)\"},\n    # the pattern is defined using spacy patterns\n    {\n        \"label\": \"medicine\",\n        \"pattern\": [[{\"IS_ALPHA\": True}, {\"LIKE_NUM\": True}, {\"LOWER\": \"mg\"}]],\n    },\n    # the pattern is defined using spacy patterns\n    {\n        \"label\": \"date\",\n        \"pattern\": [\n            [\n                {\"SHAPE\": \"dd\"},\n                {\"TEXT\": \"-\"},\n                {\"SHAPE\": \"dd\"},\n                {\"TEXT\": \"-\"},\n                {\"SHAPE\": \"dddd\"},\n            ]\n        ],\n    },\n]\n</code></pre> <p>Let us now initialize the pattern extractor.</p> <pre><code>pattern_extractor = PatternExtractor(labels, lang=LANGUAGES.ENGLISH)\n</code></pre> <p>The <code>PatternExtractor</code> receives the original text and returns the enriched text document and the extracted entities.</p> <pre><code>doc, entities = pattern_extractor(original_text)\n</code></pre> <p>The entities extracted within the input text are:</p> <pre><code>pattern_extractor.display(doc)\n</code></pre> Medical RecordPatient Name: John DoeDate of     Birth:              15-01-1985         date Date of Examination:              20-05-2024         date Social Security Number: 123-45-6789Examination Procedure:John Doe underwent a routine physical     examination. The procedure included measuring vital signs (              blood pressure, heart rate, temperature         symptoms      ), a comprehensive blood panel, and a cardiovascular stress test. The patient also reported occasional headaches and     dizziness, prompting a neurological assessment and an MRI scan to rule out any underlying issues.Medication     Prescribed:          Ibuprofen 200 mg         medicine      : Take one tablet every 6-8 hours as needed for headache and pain relief.          Lisinopril 10 mg         medicine      : Take one tablet daily to manage high blood pressure.Next Examination Date:          15-11-2024         date"},{"location":"how-to-guides/2024/07/15/extractors-overview/#multi-extractor","title":"Multi extractor","text":"<p>The MultiExtractor is a extractor that can be used to extract entities using multiple extractors.</p> <p>The motivation behind the multi extractor is the following: depending on the document format, personal information can be located in different locations; some of them can be found at similar places, while others can be found in different places and formats. Because of this, we would need to use the NERExtractor to automatically identify the entities at different locations and the PatternExtractor to extract the entities that appear at the same location.</p> <p><code>MultiExtractor</code> enables the use of both extractors at the same time. Furthermore, if both extractors identify entities at similar locations, then the <code>MultiExtractor</code> will also provide a list of joint entities.</p> <pre><code>from anonipy.anonymize.extractors import MultiExtractor\n</code></pre> <p>The <code>MultiExtractor</code> takes the following parameters:</p> <p>Parameters:</p> Name Type Description Default <code>extractors</code> <code>List[ExtractorInterface]</code> <p>The list of extractors to use.</p> required <p>In this example, we will use the previously initialized NER and pattern extractors.</p> <pre><code>multi_extractor = MultiExtractor(\n  extractors=[ner_extractor, pattern_extractor],\n)\n</code></pre> <p>Similar as before, the <code>MultiExtractor</code> receives the original text, but returns the outputs of all the extractors, as well as the joint entities from all the extractors.</p> <pre><code>extractor_outputs, joint_entities = multi_extractor(original_text)\n</code></pre> <p>In this case, <code>extractor_outputs[0]</code> will contain the <code>(doc, entities)</code> from the NER extractor, and <code>extractor_outputs[1]</code> will contain the <code>(doc, entities)</code> from the pattern extractor. The <code>joint_entities</code> will contain the joint entities from all the extractors.</p>"},{"location":"how-to-guides/2024/07/15/extractors-overview/#conclusion","title":"Conclusion","text":"<p>The extractors are used to extract entities from the text. The <code>anonipy</code> package supports both machine learning-based and pattern-based entity extraction, enabling information identification and extraction from different textual formats.</p>"},{"location":"how-to-guides/2024/07/15/generators-overview/","title":"Generators overview","text":"<p>In this post, we will show an overview of the implemented generators. The generators are used to create new texts that would serve as substitutes to the extracted <code>named entities</code>. The substitutes can be then used to replace and anonymize the text.</p> <p>All generators and their API references are available in the generators module. What follows is the presentation of the different generators <code>anonipy</code> provides.</p>"},{"location":"how-to-guides/2024/07/15/generators-overview/#pre-requisites","title":"Pre-requisites","text":"<p>Let us first define the text, from which we want to extract the entities.</p> <pre><code>original_text = \"\"\"\\\nMedical Record\n\nPatient Name: John Doe\nDate of Birth: 15-01-1985\nDate of Examination: 20-05-2024\nSocial Security Number: 123-45-6789\n\nExamination Procedure:\nJohn Doe underwent a routine physical examination. The procedure included measuring vital signs (blood pressure, heart rate, temperature), a comprehensive blood panel, and a cardiovascular stress test. The patient also reported occasional headaches and dizziness, prompting a neurological assessment and an MRI scan to rule out any underlying issues.\n\nMedication Prescribed:\n\nIbuprofen 200 mg: Take one tablet every 6-8 hours as needed for headache and pain relief.\nLisinopril 10 mg: Take one tablet daily to manage high blood pressure.\nNext Examination Date:\n15-11-2024\n\"\"\"\n</code></pre> <p>Normally, the entities would be extracted using an extractor. For this example, we manually define the entities.</p> <pre><code>from anonipy.definitions import Entity\n\nentities = [\n    Entity(\n        text=\"John Doe\",\n        label=\"name\",\n        start_index=30,\n        end_index=38,\n        type=\"string\",\n    ),\n    Entity(\n        text=\"20-05-2024\",\n        label=\"date\",\n        start_index=86,\n        end_index=96,\n        type=\"date\",\n    ),\n    Entity(\n        text=\"123-45-6789\",\n        label=\"social security number\",\n        start_index=121,\n        end_index=132,\n        type=\"custom\",\n        regex=\"\\d{3}-\\d{2}-\\d{4}\",\n    ),\n]\n</code></pre>"},{"location":"how-to-guides/2024/07/15/generators-overview/#generators","title":"Generators","text":"<p>All following generators are available in the generators module.</p>"},{"location":"how-to-guides/2024/07/15/generators-overview/#the-llm-label-generator","title":"The LLM label generator","text":"<p>The LLMLabelGenerator is a one-stop-shop generator that utilizes LLMs to generate replacements for entities. It is implemented to support any entity type.</p> <pre><code>from anonipy.anonymize.generators import LLMLabelGenerator\n</code></pre> <p>The <code>LLMLabelGenerator</code> requires the following input parameters at initialization:</p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>The name of the model to use.</p> <code>'HuggingFaceTB/SmolLM2-1.7B-Instruct'</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use GPU or not.</p> <code>False</code> <code>use_quant</code> <code>bool</code> <p>Whether to use quantization or not.</p> <code>False</code> <p>Let us now initialize the LLM label generator.</p> <pre><code>llm_generator = LLMLabelGenerator()\n</code></pre> <p>Initialization warnings</p> <p>The initialization of <code>LLMLabelGenerator</code> will throw some warnings. Ignore them. These are expected due to the use of package dependencies.</p> <p>To use the generator, we can call the <code>generate</code> method. The <code>generate</code> method receives the following parameters:</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>Entity</code> <p>The entity to generate the label from.</p> required <code>add_entity_attrs</code> <code>str</code> <p>Additional entity attribute description to add to the generation.</p> <code>''</code> <code>temperature</code> <code>float</code> <p>The temperature to use for the generation.</p> <code>1.0</code> <code>top_p</code> <code>float</code> <p>The top p to use for the generation.</p> <code>0.95</code> <p>Let us generate the replacement for the first entity from <code>entities</code> using the default parameters.</p> <pre><code>llm_generator.generate(entities[0])# (1)!\n</code></pre> <ol> <li>The generator receives the <code>John Doe</code> name entity and might return the replacement: <code>Ethan Thomson</code></li> </ol> <p>Let us now change the label prefix and generate the replacement using a higher temperature.</p> <pre><code>llm_generator.generate(\n    entities[0],\n    add_entity_attrs=\"Spanish\",\n    temperature=0.7\n)# (1)!\n</code></pre> <ol> <li>The generator receives the <code>John Doe</code> name entity and under the different generation parameters might return the replacement: <code>Juan Rodrigez</code></li> </ol> <p>Going through the whole <code>entities</code> list, the <code>LLMLabelGenerator</code>, using the default parameters, might generate the following replacements:</p> Entity Type Label Replacement <code>John Doe</code> <code>string</code> <code>name</code> <code>Ethan Thomson</code> <code>20-05-2024</code> <code>date</code> <code>date</code> <code>23-07-2027</code> <code>123-45-6789</code> <code>custom</code> <code>social security number</code> <code>987-65-4321</code> <p>Advices and suggestions</p> <p>Using LLMLabelGenerator only for string and custom types. While the <code>LLMLabelGenerator</code> is able to generate alternatives for different entity types, we suggest using it only for string and custom entity types. The reason is that the LLMs can be quite slow for generating replacements.</p> <p>In addition, <code>anonipy</code> has other generators that can be used for other entity types, such as dates, numbers, etc.</p> <p>Restricting with regex. Using LLMs to generate text is best when the generation is restricted to a specific pattern. The Entity object already contains a <code>regex</code> field that can be used to restrict the generation to a specific pattern. However, it is recommended to specify to have as specific and restrictive regex expressions as possible.</p> <p>This will help the <code>LLMLabelGenerator</code> to generate more accurate replacements.</p>"},{"location":"how-to-guides/2024/07/15/generators-overview/#the-mask-label-generator","title":"The mask label generator","text":"<p>The MaskLabelGenerator is a generator that uses smaller language models, such as XLM-RoBERTa, to generate replacements for entities. It is implemented to support any entity type, but we suggest using it only with string entities. For other entity types, please use other available generators.</p> <pre><code>from anonipy.anonymize.generators import MaskLabelGenerator\n</code></pre> <p>The <code>MaskLabelGenerator</code> requires the following input parameters at initialization:</p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>The name of the masking model to use.</p> <code>'FacebookAI/xlm-roberta-large'</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use GPU/CUDA, if available.</p> <code>False</code> <code>context_window</code> <code>int</code> <p>The context window size.</p> <code>100</code> <p>Let us now initialize the mask label generator.</p> <pre><code>mask_generator = MaskLabelGenerator()\n</code></pre> <p>Initialization warnings</p> <p>The initialization of <code>LLMLabelGenerator</code> will throw some warnings. Ignore them. These are expected due to the use of package dependencies.</p> <p>To use the generator, we can call the <code>generate</code> method. The <code>generate</code> method receives the following parameters:</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>Entity</code> <p>The entity used to generate the substitute.</p> required <code>text</code> <code>str</code> <p>The original text in which the entity is located; used to get the entity's context.</p> required <p>This generator will create a list of suggestions from which it will select one at random. Therefore, the generator will return different suggestions every time it is called.</p> <pre><code>mask_generator.generate(entities[0], text=original_text)# (1)!\nmask_generator.generate(entities[0], text=original_text)# (2)!\nmask_generator.generate(entities[0], text=original_text)# (3)!\n</code></pre> <ol> <li>The first generation for the <code>John Doe</code> name entity might return the replacement: <code>James Smith</code></li> <li>The second generation might return the replacement: <code>Michael Smith</code></li> <li>The third generation might return the replacement: <code>David Blane</code></li> </ol> <p>Advices and suggestions</p> <p>Using only for string entities. As seen from the above examples, the <code>MaskLabelGenerator</code> is best used with string entities. For number and date entities, it is best to use other generators, such as <code>NumberGenerator</code> and <code>DateGenerator</code>.</p>"},{"location":"how-to-guides/2024/07/15/generators-overview/#the-number-generator","title":"The number generator","text":"<p>The NumberGenerator is a generator for generating random numbers. It is implemented to support integers, floats, and phone numbers, but it can be used to generate values for custom types which include numbers.</p> <pre><code>from anonipy.anonymize.generators import NumberGenerator\n</code></pre> <p>The <code>NumberGenerator</code> currently does not require any input parameters at initialization.</p> <pre><code>number_generator = NumberGenerator()\n</code></pre> <p>To use the generator, we can call the <code>generate</code> method. The <code>generate</code> method receives the following parameters:</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>Entity</code> <p>The numeric entity to generate the numeric substitute.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the entity type is not <code>integer</code>, <code>float</code>, <code>phone_number</code> or <code>custom</code>.</p> <p>This generator will create a suggestion by replacing numeric values in the entity text at random. Therefore, the generator will return different suggestions every time it is called.</p> <pre><code>number_generator.generate(entities[2])# (1)!\n</code></pre> <ol> <li>For the <code>social security number</code> entity, the generator will return a replacement, such as: <code>143-46-4915</code>.</li> </ol> <p>Furthermore, it will throw an error if the entity type is not <code>integer</code>, <code>float</code>, <code>phone_number</code> or <code>custom</code>.</p> <pre><code>try:\n    number_generator.generate(entities[0])# (1)!\nexcept Exception as e:\n    print(e)# (2)!\n</code></pre> <ol> <li>The provided entity is a <code>string</code>, therefore it will raise an error.</li> <li>The exception will state <code>The entity type must be 'integer', 'float', 'phone_number' or 'custom' to generate numbers.</code></li> </ol>"},{"location":"how-to-guides/2024/07/15/generators-overview/#the-date-generator","title":"The date generator","text":"<p>The DateGenerator is a generator for generating dates. It is implemented to support date entities.</p> <pre><code>from anonipy.anonymize.generators import DateGenerator\n</code></pre> <p>The <code>DateGenerator</code> requires the following input parameters at initialization:</p> <p>Parameters:</p> Name Type Description Default <code>lang</code> <code>Union[str, LANGUAGES]</code> <p>The language of the text.</p> <code>'en'</code> <code>date_format</code> <code>str</code> <p>The date format in which the date should be generated. More on date formats see here.</p> <code>'auto'</code> <code>day_sigma</code> <code>int</code> <p>The range of the random date in days.</p> <code>30</code> <p>Let us now initialize the date generator.</p> <pre><code>date_generator = DateGenerator()\n</code></pre> <p>To use the generator, we can call the <code>generate</code> method. The <code>generate</code> method receives the following parameters:</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>Entity</code> <p>The entity to generate the date substitute from.</p> required <code>sub_variant</code> <code>DATE_TRANSFORM_VARIANTS</code> <p>The substitute function variant to use.</p> <code>RANDOM</code> <p>Using the above parameters, this generator will create the appropriate date suggestions:</p> <pre><code>entities[1]# (1)!\ndate_generator.generate(entities[1], sub_variant=\"RANDOM\")# (2)!\ndate_generator.generate(entities[1], sub_variant=\"FIRST_DAY_OF_THE_MONTH\")# (3)!\ndate_generator.generate(entities[1], sub_variant=\"LAST_DAY_OF_THE_MONTH\")# (4)!\ndate_generator.generate(entities[1], sub_variant=\"MIDDLE_OF_THE_MONTH\")# (5)!\ndate_generator.generate(entities[1], sub_variant=\"MIDDLE_OF_THE_YEAR\")# (6)!\n</code></pre> <ol> <li>The entity is a <code>date</code> entity with the text <code>20-05-2024</code>.</li> <li>The <code>RANDOM</code> sub variant will return a random date within the given date range. A possible generation can be: <code>26-05-2024</code></li> <li>The <code>FIRST_DAY_OF_THE_MONTH</code> sub variant will return the first day of the month: <code>01-05-2024</code></li> <li>The <code>LAST_DAY_OF_THE_MONTH</code> sub variant will return the last day of the month: <code>31-05-2024</code></li> <li>The <code>MIDDLE_OF_THE_MONTH</code> sub variant will return the middle day of the month: <code>15-05-2024</code></li> <li>The <code>MIDDLE_OF_THE_YEAR</code> sub variant will return the middle day of the year: <code>01-07-2024</code></li> </ol> <p>Furthermore, it will throw an error if the entity type is not <code>date</code>.</p> <pre><code>try:\n    date_generator.generate(entities[0])# (1)!\nexcept Exception as e:\n    print(e)# (2)!\n</code></pre> <ol> <li>The provided entity is a <code>string</code>, therefore it will raise an error.</li> <li>The exception will state <code>The entity type must be 'date' to generate dates.</code></li> </ol>"},{"location":"how-to-guides/2024/07/15/generators-overview/#conclusion","title":"Conclusion","text":"<p>The generators are used to create new texts that would serve as substitutes to the extracted <code>named entities</code>. The substitutes can be then used to replace and anonymize the text.</p>"},{"location":"how-to-guides/2024/07/15/strategies-overview/","title":"Strategies overview","text":"<p>In this post, we will show an overview of the implemented  strategies. The strategies delegate how the original text will be anonymized given the extracted <code>named entities</code>. They output the anonymized text and the list of replacements that were made to the original text.</p> <p>All strategies and their API references are available in the  strategies module. What follows is the presentation of the different strategies <code>anonipy</code> provides.</p>"},{"location":"how-to-guides/2024/07/15/strategies-overview/#pre-requisites","title":"Pre-requisites","text":"<p>Let us first define the text we want to anonymiyze.</p> <pre><code>original_text = \"\"\"\\\nMedical Record\n\nPatient Name: John Doe\nDate of Birth: 15-01-1985\nDate of Examination: 20-05-2024\nSocial Security Number: 123-45-6789\n\nExamination Procedure:\nJohn Doe underwent a routine physical examination. The procedure included measuring vital signs (blood pressure, heart rate, temperature), a comprehensive blood panel, and a cardiovascular stress test. The patient also reported occasional headaches and dizziness, prompting a neurological assessment and an MRI scan to rule out any underlying issues.\n\nMedication Prescribed:\n\nIbuprofen 200 mg: Take one tablet every 6-8 hours as needed for headache and pain relief.\nLisinopril 10 mg: Take one tablet daily to manage high blood pressure.\nNext Examination Date:\n15-11-2024\n\"\"\"\n</code></pre> <p>Normally, the entities would be extracted using an extractor. For this example, we manually define the entities.</p> <pre><code>from anonipy.definitions import Entity\n\nentities = [\n    Entity(\n        text=\"John Doe\",\n        label=\"name\",\n        start_index=30,\n        end_index=38,\n        type=\"string\",\n    ),\n    Entity(\n        text=\"15-01-1985\",\n        label=\"date of birth\",\n        start_index=54,\n        end_index=64,\n        type=\"date\",\n    ),\n    Entity(\n        text=\"20-05-2024\",\n        label=\"date\",\n        start_index=86,\n        end_index=96,\n        type=\"date\",\n    ),\n    Entity(\n        text=\"123-45-6789\",\n        label=\"social security number\",\n        start_index=121,\n        end_index=132,\n        type=\"custom\",\n        regex=\"[0-9]{3}-[0-9]{2}-[0-9]{4}\",\n    ),\n    Entity(\n        text=\"John Doe\",\n        label=\"name\",\n        start_index=157,\n        end_index=165,\n        type=\"string\",\n    ),\n    Entity(\n        text=\"15-11-2024\",\n        label=\"date\",\n        start_index=717,\n        end_index=727,\n        type=\"date\",\n    ),\n]\n</code></pre>"},{"location":"how-to-guides/2024/07/15/strategies-overview/#strategies","title":"Strategies","text":"<p>All following strategies are available in the strategies module.</p>"},{"location":"how-to-guides/2024/07/15/strategies-overview/#redacted-strategy","title":"Redacted Strategy","text":"<p>Data redaction is the process of obscuring information that\u2019s personally identifiable, confidential, classified or sensitive.</p> <p>The RedactionStrategy anonymizes the original text by replacing the entities in the text with a predefined substitute label, which defaults to <code>[REDACTED]</code>.</p> <p>Anonymization details</p> <p>The redaction strategy hides sensitive information by replacing the original entities with a string that does not reveal any information about the original. While this is useful for obscuring information, it does change the text's distribution, which can effect the training of machine learning models.</p> <pre><code>from anonipy.anonymize.strategies import RedactionStrategy\n</code></pre> <p>The <code>RedactionStrategy</code> requires the following input parameters at initialization:</p> <p>Parameters:</p> Name Type Description Default <code>substitute_label</code> <code>str</code> <p>The label to substitute in the anonymized text.</p> <code>'[REDACTED]'</code> <p>Let us now initialize the redaction strategy.</p> <pre><code>redaction_strategy = RedactionStrategy()\n</code></pre> <p>To use the strategy, we can call the <code>anonymize</code> method to anonymize the text given the <code>entities</code>. The <code>anonymize</code> method receives the following parameters:</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to anonymize.</p> required <code>entities</code> <code>List[Entity]</code> <p>The list of entities to anonymize.</p> required <p>Using the <code>RedactionStrategy</code>, we can now anonymize the text.</p> <pre><code>anonymized_text, replacements = redaction_strategy.anonymize(\n    original_text,\n    entities\n)\n</code></pre> <p>Which returns the anonymized text and the list of replacements made.</p> <p><pre><code>print(anonymized_text)\n</code></pre> <pre><code>Medical Record\n\nPatient Name: [REDACTED]\nDate of Birth: [REDACTED]\nDate of Examination: [REDACTED]\nSocial Security Number: [REDACTED]\n\nExamination Procedure:\n[REDACTED] underwent a routine physical examination. The procedure included measuring vital signs (blood pressure, heart rate, temperature), a comprehensive blood panel, and a cardiovascular stress test. The patient also reported occasional headaches and dizziness, prompting a neurological assessment and an MRI scan to rule out any underlying issues.\n\nMedication Prescribed:\n\nIbuprofen 200 mg: Take one tablet every 6-8 hours as needed for headache and pain relief.\nLisinopril 10 mg: Take one tablet daily to manage high blood pressure.\nNext Examination Date:\n[REDACTED]\n</code></pre></p> <p>And the associated replacements are:</p> <p><pre><code>print(replacements)\n</code></pre> <pre><code>[\n    {\n        \"original_text\": \"John Doe\",\n        \"label\": \"name\",\n        \"start_index\": 30,\n        \"end_index\": 38,\n        \"anonymized_text\": \"[REDACTED]\"\n    },\n    {\n        \"original_text\": \"15-01-1985\",\n        \"label\": \"date of birth\",\n        \"start_index\": 54,\n        \"end_index\": 64,\n        \"anonymized_text\": \"[REDACTED]\"\n    },\n    {\n        \"original_text\": \"20-05-2024\",\n        \"label\": \"date\",\n        \"start_index\": 86,\n        \"end_index\": 96,\n        \"anonymized_text\": \"[REDACTED]\"\n    },\n    {\n        \"original_text\": \"123-45-6789\",\n        \"label\": \"social security number\",\n        \"start_index\": 121,\n        \"end_index\": 132,\n        \"anonymized_text\": \"[REDACTED]\"\n    },\n    {\n        \"original_text\": \"John Doe\",\n        \"label\": \"name\",\n        \"start_index\": 157,\n        \"end_index\": 165,\n        \"anonymized_text\": \"[REDACTED]\"\n    },\n    {\n        \"original_text\": \"15-11-2024\",\n        \"label\": \"date\",\n        \"start_index\": 717,\n        \"end_index\": 727,\n        \"anonymized_text\": \"[REDACTED]\"\n    }\n]\n</code></pre></p>"},{"location":"how-to-guides/2024/07/15/strategies-overview/#masking-strategy","title":"Masking Strategy","text":"<p>Data masking refers to the disclosure of data with modified values. Data anonymization is done by creating a mirror image of a database and implementing alteration strategies, such as character shuffling, encryption, term, or character substitution. For example, a value character may be replaced by a symbol such as \u201c*\u201d or \u201cx.\u201d It makes identification or reverse engineering difficult.</p> <p>The MaskingStrategy anonymizes the original text by replacing the entities with masks, which are created using the subsitute label, which defaults to <code>*</code>.</p> <p>Anonymization details</p> <p>The masking strategy is useful as it hides the original sensitive values and retains the original text's length. However, it also changes the original text's meaning and distribution, as the replacement values are not the same as the original values.</p> <pre><code>from anonipy.anonymize.strategies import MaskingStrategy\n</code></pre> <p>The <code>MaskingStrategy</code> requires the following input parameters at initialization:</p> <p>Parameters:</p> Name Type Description Default <code>substitute_label</code> <code>str</code> <p>The label to substitute in the anonymized text.</p> <code>'*'</code> <p>Let us now initialize the masking strategy.</p> <pre><code>masking_strategy = MaskingStrategy()\n</code></pre> <p>To use the strategy, we can call the <code>anonymize</code> method to anonymize the text given the <code>entities</code>. The <code>anonymize</code> method receives the following parameters:</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to anonymize.</p> required <code>entities</code> <code>List[Entity]</code> <p>The list of entities to anonymize.</p> required <p>Using the <code>MaskingStrategy</code>, we can now anonymize the text.</p> <pre><code>anonymized_text, replacements = masking_strategy.anonymize(\n    original_text,\n    entities\n)\n</code></pre> <p>Which returns the anonymized text and the list of replacements made.</p> <p><pre><code>print(anonymized_text)\n</code></pre> <pre><code>Patient Name: **** ***\nDate of Birth: **********\nDate of Examination: **********\nSocial Security Number: ***********\n\nExamination Procedure:\n**** *** underwent a routine physical examination. The procedure included measuring vital signs (blood pressure, heart rate, temperature), a comprehensive blood panel, and a cardiovascular stress test. The patient also reported occasional headaches and dizziness, prompting a neurological assessment and an MRI scan to rule out any underlying issues.\n\nMedication Prescribed:\n\nIbuprofen 200 mg: Take one tablet every 6-8 hours as needed for headache and pain relief.\nLisinopril 10 mg: Take one tablet daily to manage high blood pressure.\nNext Examination Date:\n**********\n</code></pre></p> <p>And the associated replacements are:</p> <p><pre><code>print(replacements)\n</code></pre> <pre><code>[\n    {\n        \"original_text\": \"John Doe\",\n        \"label\": \"name\",\n        \"start_index\": 30,\n        \"end_index\": 38,\n        \"anonymized_text\": \"**** ***\"\n    },\n    {\n        \"original_text\": \"15-01-1985\",\n        \"label\": \"date of birth\",\n        \"start_index\": 54,\n        \"end_index\": 64,\n        \"anonymized_text\": \"**********\"\n    },\n    {\n        \"original_text\": \"20-05-2024\",\n        \"label\": \"date\",\n        \"start_index\": 86,\n        \"end_index\": 96,\n        \"anonymized_text\": \"**********\"\n    },\n    {\n        \"original_text\": \"123-45-6789\",\n        \"label\": \"social security number\",\n        \"start_index\": 121,\n        \"end_index\": 132,\n        \"anonymized_text\": \"***********\"\n    },\n    {\n        \"original_text\": \"John Doe\",\n        \"label\": \"name\",\n        \"start_index\": 157,\n        \"end_index\": 165,\n        \"anonymized_text\": \"**** ***\"\n    },\n    {\n        \"original_text\": \"15-11-2024\",\n        \"label\": \"date\",\n        \"start_index\": 717,\n        \"end_index\": 727,\n        \"anonymized_text\": \"**********\"\n    }\n]\n</code></pre></p>"},{"location":"how-to-guides/2024/07/15/strategies-overview/#pseudonymization-strategy","title":"Pseudonymization Strategy","text":"<p>Pseudonymization is a data de-identification tool that substitutes private identifiers with false identifiers or pseudonyms, such as swapping the \u201cJohn Smith\u201d identifier with the \u201cMark Spencer\u201d identifier. It maintains statistical precision and data confidentiality, allowing changed data to be used for creation, training, testing, and analysis, while at the same time maintaining data privacy.</p> <p>The PseudonymizationStrategy anonymizes the original text by replacing the entities with fake ones, which are created using the generators (see generators).</p> <p>Anonymization details</p> <p>The pseudonymization strategy is the most useful in terms of retaining the statistical distributions of the text. However, it is also most technical, as the user must define a function for mapping true entities to fake ones. Furthermore, if an entity appears multiple times the pseudonymization strategy will retain the same mapping between the true and fake entities.</p> <p>The <code>PseudonymizationStrategy</code> requires a function for mapping entities. In our example, we will define a function using the generators. To make the example accessible as possible, we will use the MaskLabelGenerator instead of the LLMLabelGenerator for generating string entities.</p> <p>First, let us define the mapping function. We will import the required generators and initialize them.</p> <pre><code>from anonipy.anonymize.generators import (\n    MaskLabelGenerator,\n    DateGenerator,\n    NumberGenerator,\n)\n\n# initialize the generators\nmask_generator = MaskLabelGenerator()\ndate_generator = DateGenerator()\nnumber_generator = NumberGenerator()\n</code></pre> <p>Next, we will define the anonymization mapping function. This function receives two inputs: <code>text</code> and the <code>entity</code>. The <code>text</code> is the original text, and the <code>entity</code> is the current entity. The anonymization mapping will create a replacement for the given <code>entity</code> based on it's information and context within the <code>text</code>.</p> <pre><code>def anonymization_mapping(text, entity):\n    if entity.type == \"string\":\n        return mask_generator.generate(entity, text)\n    if entity.label == \"date\":\n        return date_generator.generate(entity, sub_variant=\"MIDDLE_OF_THE_MONTH\")\n    if entity.label == \"date of birth\":\n        return date_generator.generate(entity, sub_variant=\"MIDDLE_OF_THE_YEAR\")\n    if entity.label == \"social security number\":\n        return number_generator.generate(entity)\n    return \"[REDACTED]\"\n</code></pre> <p>Let us now initialize the pseudonymization strategy.</p> <pre><code>from anonipy.anonymize.strategies import PseudonymizationStrategy\n</code></pre> <p>The <code>PseudonymizationStrategy</code> requires the following input parameters at initialization:</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Callable</code> <p>The mapping function on how to handle each entity type.</p> required <p>Let us now initialize the pseudonymization strategy.</p> <pre><code>pseudo_strategy = PseudonymizationStrategy(\n    mapping=anonymization_mapping\n)\n</code></pre> <p>To use the strategy, we can call the <code>anonymize</code> method to anonymize the text given the <code>entities</code>. The <code>anonymize</code> method receives the following parameters:</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to anonymize.</p> required <code>entities</code> <code>List[Entity]</code> <p>The list of entities to anonymize.</p> required <p>Using the <code>PseudonymizationStrategy</code>, we can now anonymize the text.</p> <pre><code>anonymized_text, replacements = pseudo_strategy.anonymize(\n    original_text,\n    entities\n)\n</code></pre> <p>Which returns the anonymized text and the list of replacements made.</p> <p>Generator performance</p> <p>While <code>MaskLabelGenerator</code> is faster and less resource intensive than <code>LLMLabelGenerator</code>, it sometimes does not provide a meaningful replacement. In the example below, the patient name <code>John Doe</code> is replaced with <code>first Professor</code>, which is not meaningful. Therefore, when possible, we advise using the <code>LLMLabelGenerator</code> instead.</p> <p><pre><code>print(anonymized_text)\n</code></pre> <pre><code>Medical Record\n\nPatient Name: first Professor\nDate of Birth: 01-07-1985\nDate of Examination: 15-05-2024\nSocial Security Number: 724-78-8182\n\nExamination Procedure:\nfirst Professor underwent a routine physical examination. The procedure included measuring vital signs (blood pressure, heart rate, temperature), a comprehensive blood panel, and a cardiovascular stress test. The patient also reported occasional headaches and dizziness, prompting a neurological assessment and an MRI scan to rule out any underlying issues.\n\nMedication Prescribed:\n\nIbuprofen 200 mg: Take one tablet every 6-8 hours as needed for headache and pain relief.\nLisinopril 10 mg: Take one tablet daily to manage high blood pressure.\nNext Examination Date:\n15-11-2024\n</code></pre></p> <p>And the associated replacements are:</p> <p><pre><code>print(replacements)\n</code></pre> <pre><code>[\n    {\n        \"original_text\": \"John Doe\",\n        \"label\": \"name\",\n        \"start_index\": 30,\n        \"end_index\": 38,\n        \"anonymized_text\": \"first Professor\"\n    },\n    {\n        \"original_text\": \"15-01-1985\",\n        \"label\": \"date of birth\",\n        \"start_index\": 54,\n        \"end_index\": 64,\n        \"anonymized_text\": \"01-07-1985\"\n    },\n    {\n        \"original_text\": \"20-05-2024\",\n        \"label\": \"date\",\n        \"start_index\": 86,\n        \"end_index\": 96,\n        \"anonymized_text\": \"15-05-2024\"\n    },\n    {\n        \"original_text\": \"123-45-6789\",\n        \"label\": \"social security number\",\n        \"start_index\": 121,\n        \"end_index\": 132,\n        \"anonymized_text\": \"724-78-8182\"\n    },\n    {\n        \"original_text\": \"John Doe\",\n        \"label\": \"name\",\n        \"start_index\": 157,\n        \"end_index\": 165,\n        \"anonymized_text\": \"first Professor\"\n    },\n    {\n        \"original_text\": \"15-11-2024\",\n        \"label\": \"date\",\n        \"start_index\": 717,\n        \"end_index\": 727,\n        \"anonymized_text\": \"15-11-2024\"\n    }\n]\n</code></pre></p>"},{"location":"how-to-guides/2024/07/15/strategies-overview/#conclusion","title":"Conclusion","text":"<p>The strategies are used to anonymize the text in combination with the extracted <code>named entities</code>. The strategies are used to replace and anonymize the text as well as provide the list of replacements that were made to the original text.</p>"},{"location":"references/","title":"Anonipy Module","text":""},{"location":"references/#anonipy","title":"<code>anonipy</code>","text":"<p><code>Anonipy</code> is a text anonymization package.</p> <p>The <code>anonipy</code> package provides utilities for data anonymization. It provides a set of modules and utilities for (1) identifying relevant information that needs to be anonymized, (2) generating substitutes for the identified information, and (3) strategies for anonymizing the identified information.</p> <p>Modules:</p> Name Description <code>anonymize</code> <p>The module containing the anonymization submodules and utility.</p> <code>utils</code> <p>The module containing utility classes and functions.</p> <code>definitions</code> <p>The module containing predefined types used across the package.</p> <code>constants</code> <p>The module containing the predefined constants used across the package.</p>"},{"location":"references/constants/","title":"Constants Module","text":""},{"location":"references/constants/#anonipy.constants","title":"<code>anonipy.constants</code>","text":"<p>Module containing the <code>constants</code>.</p> <p>The <code>constants</code> module provides a set of predefined constants used in the package. These include supported languages, types of entities, and date transformation variants.</p> <p>Classes:</p> Name Description <code>LANGUAGES</code> <p>Predefined supported languages.</p> <code>ENTITY_TYPES</code> <p>Predefined types of entities.</p> <code>DATE_TRANSFORM_VARIANTS</code> <p>Predefined types of the date transformation variants.</p>"},{"location":"references/constants/#anonipy.constants.LANGUAGES","title":"<code>LANGUAGES</code>","text":"<p>The main anonipy supported languages.</p> <p>Attributes:</p> Name Type Description <code>DUTCH</code> <code>Tuple[Literal[nl], Literal[Dutch]]</code> <p>The Dutch language.</p> <code>ENGLISH</code> <code>Tuple[Literal[en], Literal[English]]</code> <p>The English language.</p> <code>FRENCH</code> <code>Tuple[Literal[fr], Literal[French]]</code> <p>The French language.</p> <code>GERMAN</code> <code>Tuple[Literal[de], Literal[German]]</code> <p>The German language.</p> <code>GREEK</code> <code>Tuple[Literal[el], Literal[Greek]]</code> <p>The Greek language.</p> <code>ITALIAN</code> <code>Tuple[Literal[it], Literal[Italian]]</code> <p>The Italian language.</p> <code>SLOVENIAN</code> <code>Tuple[Literal[sl], Literal[Slovenian]]</code> <p>The Slovenian language.</p> <code>SPANISH</code> <code>Tuple[Literal[es], Literal[Spanish]]</code> <p>The Spanish language.</p> <code>UKRAINIAN</code> <code>Tuple[Literal[uk], Literal[Ukrainian]]</code> <p>The Ukrainian language.</p> <p>Methods:</p> Name Description <code>supported_languages</code> <p>Return a list of supported languages.</p> Source code in <code>anonipy/constants.py</code> <pre><code>class LANGUAGES:\n    \"\"\"The main anonipy supported languages.\n\n    Attributes:\n        DUTCH (Tuple[Literal[\"nl\"], Literal[\"Dutch\"]]): The Dutch language.\n        ENGLISH (Tuple[Literal[\"en\"], Literal[\"English\"]]): The English language.\n        FRENCH (Tuple[Literal[\"fr\"], Literal[\"French\"]]): The French language.\n        GERMAN (Tuple[Literal[\"de\"], Literal[\"German\"]]): The German language.\n        GREEK (Tuple[Literal[\"el\"], Literal[\"Greek\"]]): The Greek language.\n        ITALIAN (Tuple[Literal[\"it\"], Literal[\"Italian\"]]): The Italian language.\n        SLOVENIAN (Tuple[Literal[\"sl\"], Literal[\"Slovenian\"]]): The Slovenian language.\n        SPANISH (Tuple[Literal[\"es\"], Literal[\"Spanish\"]]): The Spanish language.\n        UKRAINIAN (Tuple[Literal[\"uk\"], Literal[\"Ukrainian\"]]): The Ukrainian language.\n\n    Methods:\n        supported_languages():\n            Return a list of supported languages.\n\n    \"\"\"\n\n    DUTCH = (\"nl\", \"Dutch\")\n    ENGLISH = (\"en\", \"English\")\n    FRENCH = (\"fr\", \"French\")\n    GERMAN = (\"de\", \"German\")\n    GREEK = (\"el\", \"Greek\")\n    ITALIAN = (\"it\", \"Italian\")\n    SLOVENIAN = (\"sl\", \"Slovenian\")\n    SPANISH = (\"es\", \"Spanish\")\n    UKRAINIAN = (\"uk\", \"Ukrainian\")\n\n    @classmethod\n    def supported_languages(self) -&gt; List[str]:\n        \"\"\"Return a list of supported languages.\n\n        Returns:\n            The list of supported languages.\n\n        \"\"\"\n        return [lang[0] for lang in self.__dict__.values() if isinstance(lang, tuple)]\n</code></pre>"},{"location":"references/constants/#anonipy.constants.LANGUAGES.supported_languages","title":"<code>supported_languages()</code>  <code>classmethod</code>","text":"<p>Return a list of supported languages.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>The list of supported languages.</p> Source code in <code>anonipy/constants.py</code> <pre><code>@classmethod\ndef supported_languages(self) -&gt; List[str]:\n    \"\"\"Return a list of supported languages.\n\n    Returns:\n        The list of supported languages.\n\n    \"\"\"\n    return [lang[0] for lang in self.__dict__.values() if isinstance(lang, tuple)]\n</code></pre>"},{"location":"references/constants/#anonipy.constants.ENTITY_TYPES","title":"<code>ENTITY_TYPES</code>","text":"<p>The anonipy supported entity types.</p> <p>Attributes:</p> Name Type Description <code>CUSTOM</code> <code>Literal[custom]</code> <p>The custom entity type.</p> <code>STRING</code> <code>Literal[string]</code> <p>The string entity type.</p> <code>INTEGER</code> <code>Literal[integer]</code> <p>The integer entity type.</p> <code>FLOAT</code> <code>Literal[float]</code> <p>The float entity type.</p> <code>DATE</code> <code>Literal[date]</code> <p>The date entity type.</p> <code>EMAIL</code> <code>Literal[email]</code> <p>The email entity type.</p> <code>WEBSITE_URL</code> <code>Literal[website_url]</code> <p>The website url entity type.</p> <code>PHONE_NUMBER</code> <code>Literal[phone_number]</code> <p>The phone number entity type.</p> Source code in <code>anonipy/constants.py</code> <pre><code>class ENTITY_TYPES:\n    \"\"\"The anonipy supported entity types.\n\n    Attributes:\n        CUSTOM (Literal[\"custom\"]): The custom entity type.\n        STRING (Literal[\"string\"]): The string entity type.\n        INTEGER (Literal[\"integer\"]): The integer entity type.\n        FLOAT (Literal[\"float\"]): The float entity type.\n        DATE (Literal[\"date\"]): The date entity type.\n        EMAIL (Literal[\"email\"]): The email entity type.\n        WEBSITE_URL (Literal[\"website_url\"]): The website url entity type.\n        PHONE_NUMBER (Literal[\"phone_number\"]): The phone number entity type.\n\n    \"\"\"\n\n    CUSTOM = \"custom\"\n    STRING = \"string\"\n    INTEGER = \"integer\"\n    FLOAT = \"float\"\n    DATE = \"date\"\n    EMAIL = \"email\"\n    WEBSITE_URL = \"website_url\"\n    PHONE_NUMBER = \"phone_number\"\n</code></pre>"},{"location":"references/constants/#anonipy.constants.DATE_TRANSFORM_VARIANTS","title":"<code>DATE_TRANSFORM_VARIANTS</code>","text":"<p>The supported date transform variants.</p> <p>Attributes:</p> Name Type Description <code>FIRST_DAY_OF_THE_MONTH</code> <code>Literal[FIRST_DAY_OF_THE_MONTH]</code> <p>The first day of the month.</p> <code>LAST_DAY_OF_THE_MONTH</code> <code>Literal[LAST_DAY_OF_THE_MONTH]</code> <p>The last day of the month.</p> <code>MIDDLE_OF_THE_MONTH</code> <code>Literal[MIDDLE_OF_THE_MONTH]</code> <p>The middle of the month.</p> <code>MIDDLE_OF_THE_YEAR</code> <code>Literal[MIDDLE_OF_THE_YEAR]</code> <p>The middle of the year.</p> <code>RANDOM</code> <code>Literal[RANDOM]</code> <p>A random date.</p> <p>Methods:</p> Name Description <code>values</code> <p>Return a list of all possible date transform variants.</p> <code>is_valid</code> <p>Check if the value is a valid date variant.</p> Source code in <code>anonipy/constants.py</code> <pre><code>class DATE_TRANSFORM_VARIANTS:\n    \"\"\"The supported date transform variants.\n\n    Attributes:\n        FIRST_DAY_OF_THE_MONTH (Literal[\"FIRST_DAY_OF_THE_MONTH\"]): The first day of the month.\n        LAST_DAY_OF_THE_MONTH (Literal[\"LAST_DAY_OF_THE_MONTH\"]): The last day of the month.\n        MIDDLE_OF_THE_MONTH (Literal[\"MIDDLE_OF_THE_MONTH\"]): The middle of the month.\n        MIDDLE_OF_THE_YEAR (Literal[\"MIDDLE_OF_THE_YEAR\"]): The middle of the year.\n        RANDOM (Literal[\"RANDOM\"]): A random date.\n\n    Methods:\n        values():\n            Return a list of all possible date transform variants.\n        is_valid(value):\n            Check if the value is a valid date variant.\n\n    \"\"\"\n\n    FIRST_DAY_OF_THE_MONTH = \"FIRST_DAY_OF_THE_MONTH\"\n    LAST_DAY_OF_THE_MONTH = \"LAST_DAY_OF_THE_MONTH\"\n    MIDDLE_OF_THE_MONTH = \"MIDDLE_OF_THE_MONTH\"\n    MIDDLE_OF_THE_YEAR = \"MIDDLE_OF_THE_YEAR\"\n    RANDOM = \"RANDOM\"\n\n    @classmethod\n    def values(self) -&gt; List[str]:\n        \"\"\"Return a list of all possible date transform variants.\n\n        Returns:\n            The list of all possible variants.\n\n        \"\"\"\n        return [\n            self.FIRST_DAY_OF_THE_MONTH,\n            self.LAST_DAY_OF_THE_MONTH,\n            self.MIDDLE_OF_THE_MONTH,\n            self.MIDDLE_OF_THE_YEAR,\n            self.RANDOM,\n        ]\n\n    @classmethod\n    def is_valid(self, value: str) -&gt; bool:\n        \"\"\"Check if the value is a valid date variant.\n\n        Args:\n            value: The value to check.\n\n        Returns:\n            `True` if the value is a valid date variant, `False` otherwise.\n\n        \"\"\"\n        return value in self.values()\n</code></pre>"},{"location":"references/constants/#anonipy.constants.DATE_TRANSFORM_VARIANTS.values","title":"<code>values()</code>  <code>classmethod</code>","text":"<p>Return a list of all possible date transform variants.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>The list of all possible variants.</p> Source code in <code>anonipy/constants.py</code> <pre><code>@classmethod\ndef values(self) -&gt; List[str]:\n    \"\"\"Return a list of all possible date transform variants.\n\n    Returns:\n        The list of all possible variants.\n\n    \"\"\"\n    return [\n        self.FIRST_DAY_OF_THE_MONTH,\n        self.LAST_DAY_OF_THE_MONTH,\n        self.MIDDLE_OF_THE_MONTH,\n        self.MIDDLE_OF_THE_YEAR,\n        self.RANDOM,\n    ]\n</code></pre>"},{"location":"references/constants/#anonipy.constants.DATE_TRANSFORM_VARIANTS.is_valid","title":"<code>is_valid(value)</code>  <code>classmethod</code>","text":"<p>Check if the value is a valid date variant.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The value to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the value is a valid date variant, <code>False</code> otherwise.</p> Source code in <code>anonipy/constants.py</code> <pre><code>@classmethod\ndef is_valid(self, value: str) -&gt; bool:\n    \"\"\"Check if the value is a valid date variant.\n\n    Args:\n        value: The value to check.\n\n    Returns:\n        `True` if the value is a valid date variant, `False` otherwise.\n\n    \"\"\"\n    return value in self.values()\n</code></pre>"},{"location":"references/definitions/","title":"Definitions Module","text":""},{"location":"references/definitions/#anonipy.definitions","title":"<code>anonipy.definitions</code>","text":"<p>Module containing the <code>definitions</code>.</p> <p>The <code>definitions</code> module provides a set of predefined types used in the package.</p> <p>Classes:</p> Name Description <code>Entity</code> <p>The class representing the anonipy entity object.</p> <code>Replacement</code> <p>The class representing the anonipy replacement object.</p>"},{"location":"references/definitions/#anonipy.definitions.Entity","title":"<code>Entity</code>  <code>dataclass</code>","text":"<p>The class representing the anonipy Entity object.</p> <p>Attributes:</p> Name Type Description <code>text</code> <code>str</code> <p>The text of the entity.</p> <code>label</code> <code>str</code> <p>The label of the entity.</p> <code>start_index</code> <code>int</code> <p>The start index of the entity in the text.</p> <code>end_index</code> <code>int</code> <p>The end index of the entity in the text.</p> <code>score</code> <code>float</code> <p>The prediction score of the entity. The score is returned by the extractor models.</p> <code>type</code> <code>ENTITY_TYPES</code> <p>The type of the entity.</p> <code>regex</code> <code>Union[str, Pattern]</code> <p>The regular expression the entity must match.</p> Source code in <code>anonipy/definitions.py</code> <pre><code>@dataclass\nclass Entity:\n    \"\"\"The class representing the anonipy Entity object.\n\n    Attributes:\n        text (str): The text of the entity.\n        label (str): The label of the entity.\n        start_index (int): The start index of the entity in the text.\n        end_index (int): The end index of the entity in the text.\n        score (float): The prediction score of the entity. The score is returned by the extractor models.\n        type (ENTITY_TYPES): The type of the entity.\n        regex (Union[str, re.Pattern]): The regular expression the entity must match.\n\n    \"\"\"\n\n    text: str\n    label: str\n    start_index: int\n    end_index: int\n    score: float = 1.0\n    type: ENTITY_TYPES = None\n    regex: Union[str, re.Pattern] = None\n\n    def __post_init__(self):\n        if self.regex is None:\n            if self.type == \"custom\":\n                raise ValueError(\"Custom entities require a regex.\")\n            self.regex = regex_mapping[self.type]\n\n    def get_regex_group(self) -&gt; Union[str, None]:\n        \"\"\"Get the regex group.\n\n        Returns:\n            The regex group.\n\n        \"\"\"\n\n        p_match = re.match(r\"^.*?\\((.*)\\).*$\", self.regex)\n        return p_match.group(1) if p_match else self.regex\n\n    def __str__(self) -&gt; str:\n        \"\"\"String representation of the entity.\n\n        Returns:\n            The string representation of the entity.\n\n        \"\"\"\n        return f\"Entity(text='{self.text}', label='{self.label}', start_index={self.start_index}, end_index={self.end_index}, type='{self.type}')\"\n</code></pre>"},{"location":"references/definitions/#anonipy.definitions.Entity.get_regex_group","title":"<code>get_regex_group()</code>","text":"<p>Get the regex group.</p> <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>The regex group.</p> Source code in <code>anonipy/definitions.py</code> <pre><code>def get_regex_group(self) -&gt; Union[str, None]:\n    \"\"\"Get the regex group.\n\n    Returns:\n        The regex group.\n\n    \"\"\"\n\n    p_match = re.match(r\"^.*?\\((.*)\\).*$\", self.regex)\n    return p_match.group(1) if p_match else self.regex\n</code></pre>"},{"location":"references/definitions/#anonipy.definitions.Entity.__str__","title":"<code>__str__()</code>","text":"<p>String representation of the entity.</p> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the entity.</p> Source code in <code>anonipy/definitions.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"String representation of the entity.\n\n    Returns:\n        The string representation of the entity.\n\n    \"\"\"\n    return f\"Entity(text='{self.text}', label='{self.label}', start_index={self.start_index}, end_index={self.end_index}, type='{self.type}')\"\n</code></pre>"},{"location":"references/definitions/#anonipy.definitions.Replacement","title":"<code>Replacement</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>The class representing the anonipy Replacement object.</p> <p>Attributes:</p> Name Type Description <code>original_text</code> <code>str</code> <p>The original text of the entity.</p> <code>label</code> <code>str</code> <p>The label of the entity.</p> <code>start_index</code> <code>int</code> <p>The start index of the entity in the text.</p> <code>end_index</code> <code>int</code> <p>The end index of the entity in the text.</p> <code>anonymized_text</code> <code>str</code> <p>The anonymized text replacing the original.</p> Source code in <code>anonipy/definitions.py</code> <pre><code>class Replacement(TypedDict):\n    \"\"\"The class representing the anonipy Replacement object.\n\n    Attributes:\n        original_text (str): The original text of the entity.\n        label (str): The label of the entity.\n        start_index (int): The start index of the entity in the text.\n        end_index (int): The end index of the entity in the text.\n        anonymized_text (str): The anonymized text replacing the original.\n\n    \"\"\"\n\n    original_text: NotRequired[str]\n    label: NotRequired[str]\n    start_index: int\n    end_index: int\n    anonymized_text: str\n</code></pre>"},{"location":"references/anonymize/","title":"Anonymize Module","text":""},{"location":"references/anonymize/#anonipy.anonymize","title":"<code>anonipy.anonymize</code>","text":"<p>Module containing the anonymization modules and utility.</p> <p>The <code>anonymize</code> module provides a set of anonymization modules and utility, including <code>extractors</code>, <code>generators</code>, and <code>strategies</code>. In addition, it provides methods for anonymizing text based on a list of replacements, as well as a <code>pipeline</code> class for automating the anonymization process.</p> <p>Modules:</p> Name Description <code>extractors</code> <p>The module containing the extractor classes.</p> <code>generators</code> <p>The module containing the generator classes.</p> <code>strategies</code> <p>The module containing the strategy classes.</p> <code>pipeline</code> <p>The module containing the pipeline class.</p> <p>Functions:</p> Name Description <code>anonymize</code> <p>Anonymize the text based on the replacements.</p>"},{"location":"references/anonymize/#functions","title":"Functions","text":""},{"location":"references/anonymize/#anonipy.anonymize.anonymize","title":"<code>anonipy.anonymize.anonymize(text, replacements)</code>","text":"<p>Anonymize a text based on a list of replacements.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize import anonymize\n&gt;&gt;&gt; anonymize(text, replacements)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to anonymize.</p> required <code>replacements</code> <code>List[Replacement]</code> <p>The list of replacements to apply.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The anonymized text.</p> Source code in <code>anonipy/anonymize/helpers.py</code> <pre><code>def anonymize(text: str, replacements: List[Replacement]) -&gt; str:\n    \"\"\"Anonymize a text based on a list of replacements.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize import anonymize\n        &gt;&gt;&gt; anonymize(text, replacements)\n\n    Args:\n        text: The text to anonymize.\n        replacements: The list of replacements to apply.\n\n    Returns:\n        The anonymized text.\n\n    \"\"\"\n\n    s_replacements = sorted(replacements, key=lambda x: x[\"start_index\"], reverse=True)\n\n    anonymized_text = text\n    for replacement in s_replacements:\n        anonymized_text = (\n            anonymized_text[: replacement[\"start_index\"]]\n            + replacement[\"anonymized_text\"]\n            + anonymized_text[replacement[\"end_index\"] :]\n        )\n    return anonymized_text, s_replacements[::-1]\n</code></pre>"},{"location":"references/anonymize/extractors/","title":"Extractors Module","text":""},{"location":"references/anonymize/extractors/#anonipy.anonymize.extractors","title":"<code>anonipy.anonymize.extractors</code>","text":"<p>Module containing the <code>extractors</code>.</p> <p>The <code>extractors</code> module provides a set of extractors used to identify relevant information within a document.</p> <p>Classes:</p> Name Description <code>NERExtractor</code> <p>The class representing the named entity recognition (NER) extractor.</p> <code>PatternExtractor</code> <p>The class representing the pattern extractor.</p> <code>MultiExtractor</code> <p>The class representing the multi extractor.</p>"},{"location":"references/anonymize/extractors/#anonipy.anonymize.extractors.NERExtractor","title":"<code>anonipy.anonymize.extractors.NERExtractor</code>","text":"<p>               Bases: <code>ExtractorInterface</code></p> <p>The class representing the named entity recognition (NER) extractor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.constants import LANGUAGES\n&gt;&gt;&gt; from anonipy.anonymize.extractors import NERExtractor\n&gt;&gt;&gt; labels = [{\"label\": \"PERSON\", \"type\": \"string\"}]\n&gt;&gt;&gt; extractor = NERExtractor(labels, lang=LANGUAGES.ENGLISH)\n&gt;&gt;&gt; extractor(\"John Doe is a 19 year old software engineer.\", detect_repeats=False)\nDoc, [Entity]\n</code></pre> <p>Attributes:</p> Name Type Description <code>labels</code> <code>List[dict]</code> <p>The list of labels to extract.</p> <code>lang</code> <code>str</code> <p>The language of the text to extract.</p> <code>score_th</code> <code>float</code> <p>The score threshold.</p> <code>use_gpu</code> <code>bool</code> <p>Whether to use GPU.</p> <code>gliner_model</code> <code>str</code> <p>The gliner model to use.</p> <code>pipeline</code> <code>Language</code> <p>The spacy pipeline for extracting entities.</p> <code>spacy_style</code> <code>str</code> <p>The style the entities should be stored in the spacy doc.</p> <p>Methods:</p> Name Description <code>__call__</code> <p>Extract the entities from the text.</p> <code>display</code> <p>Display the entities in the text.</p> Source code in <code>anonipy/anonymize/extractors/ner_extractor.py</code> <pre><code>class NERExtractor(ExtractorInterface):\n    \"\"\"The class representing the named entity recognition (NER) extractor.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.constants import LANGUAGES\n        &gt;&gt;&gt; from anonipy.anonymize.extractors import NERExtractor\n        &gt;&gt;&gt; labels = [{\"label\": \"PERSON\", \"type\": \"string\"}]\n        &gt;&gt;&gt; extractor = NERExtractor(labels, lang=LANGUAGES.ENGLISH)\n        &gt;&gt;&gt; extractor(\"John Doe is a 19 year old software engineer.\", detect_repeats=False)\n        Doc, [Entity]\n\n    Attributes:\n        labels (List[dict]): The list of labels to extract.\n        lang (str): The language of the text to extract.\n        score_th (float): The score threshold.\n        use_gpu (bool): Whether to use GPU.\n        gliner_model (str): The gliner model to use.\n        pipeline (Language): The spacy pipeline for extracting entities.\n        spacy_style (str): The style the entities should be stored in the spacy doc.\n\n    Methods:\n        __call__(self, text):\n            Extract the entities from the text.\n        display(self, doc):\n            Display the entities in the text.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        labels: List[dict],\n        *args,\n        lang: LANGUAGES = LANGUAGES.ENGLISH,\n        score_th: float = 0.5,\n        use_gpu: bool = False,\n        gliner_model: str = \"E3-JSI/gliner-multi-pii-domains-v1\",\n        spacy_style: str = \"ent\",\n        **kwargs,\n    ):\n        \"\"\"Initialize the named entity recognition (NER) extractor.\n\n        Examples:\n            &gt;&gt;&gt; from anonipy.constants import LANGUAGES\n            &gt;&gt;&gt; from anonipy.anonymize.extractors import NERExtractor\n            &gt;&gt;&gt; labels = [{\"label\": \"PERSON\", \"type\": \"string\"}]\n            &gt;&gt;&gt; extractor = NERExtractor(labels, lang=LANGUAGES.ENGLISH)\n            NERExtractor()\n\n        Args:\n            labels: The list of labels to extract.\n            lang: The language of the text to extract.\n            score_th: The score threshold. Entities with a score below this threshold will be ignored.\n            use_gpu: Whether to use GPU.\n            gliner_model: The gliner model to use to identify the entities.\n            spacy_style: The style the entities should be stored in the spacy doc. Options: `ent` or `span`.\n\n        \"\"\"\n\n        super().__init__(labels, *args, **kwargs)\n        self.lang = lang\n        self.score_th = score_th\n        self.use_gpu = use_gpu\n        self.gliner_model = gliner_model\n        self.spacy_style = spacy_style\n        self.labels = self._prepare_labels(labels)\n\n        with warnings.catch_warnings():\n            # TODO: remove once the GLiNER package includes the fix (inproper file closing)\n            warnings.filterwarnings(\"ignore\", category=ResourceWarning)\n            self.pipeline = self._prepare_pipeline()\n\n    def __call__(\n        self, text: str, detect_repeats: bool = False, *args, **kwargs\n    ) -&gt; Tuple[Doc, List[Entity]]:\n        \"\"\"Extract the entities from the text.\n\n        Examples:\n            &gt;&gt;&gt; extractor(\"John Doe is a 19 year old software engineer.\", detect_repeats=False)\n            Doc, [Entity]\n\n        Args:\n            text: The text to extract entities from.\n            detect_repeats: Whether to check text again for repeated entities.\n\n        Returns:\n            The spacy document.\n            The list of extracted entities.\n\n        \"\"\"\n\n        doc = self.pipeline(text)\n        anoni_entities, spacy_entities = self._prepare_entities(doc)\n\n        if detect_repeats:\n            anoni_entities = detect_repeated_entities(\n                doc, anoni_entities, self.spacy_style\n            )\n\n        create_spacy_entities(doc, anoni_entities, self.spacy_style)\n\n        return doc, anoni_entities\n\n    def display(self, doc: Doc, page: bool = False, jupyter: bool = None) -&gt; str:\n        \"\"\"Display the entities in the text.\n\n        Examples:\n            &gt;&gt;&gt; doc, entities = extractor(\"John Doe is a 19 year old software engineer.\")\n            &gt;&gt;&gt; extractor.display(doc)\n            HTML\n\n        Args:\n            doc: The spacy doc to display.\n            page: Whether to display the doc in a web browser.\n            jupyter: Whether to display the doc in a jupyter notebook.\n\n        Returns:\n            The HTML representation of the document and the extracted entities.\n\n        \"\"\"\n\n        options = {\n            \"colors\": {l[\"label\"]: get_label_color(l[\"label\"]) for l in self.labels}\n        }\n        return displacy.render(\n            doc, style=self.spacy_style, options=options, page=page, jupyter=jupyter\n        )\n\n    # ===========================================\n    # Private methods\n    # ===========================================\n\n    def _prepare_labels(self, labels: List[dict]) -&gt; List[dict]:\n        \"\"\"Prepare the labels for the extractor.\n\n        The provided labels are enriched with the corresponding regex\n        definitions, if the `regex` key was not provided.\n\n        Args:\n            labels: The list of labels to prepare.\n\n        Returns:\n            The enriched labels.\n\n        \"\"\"\n        for l in labels:\n            if \"regex\" in l:\n                continue\n            regex = regex_mapping[l[\"type\"]]\n            if regex is not None:\n                l[\"regex\"] = regex\n        return labels\n\n    def _create_gliner_config(self) -&gt; dict:\n        \"\"\"Create the config for the GLINER model.\n\n        Returns:\n            The configuration dictionary for the GLINER model.\n\n        \"\"\"\n\n        map_location = \"cpu\"\n        if self.use_gpu and not torch.cuda.is_available():\n            return warnings.warn(\n                \"The user requested GPU use, but not available GPU was found. Reverting back to CPU use.\"\n            )\n        if self.use_gpu and torch.cuda.is_available():\n            map_location = \"cuda\"\n\n        return {\n            # the model is specialized for extracting PII data\n            \"gliner_model\": self.gliner_model,\n            \"labels\": [l[\"label\"] for l in self.labels],\n            \"threshold\": self.score_th,\n            \"chunk_size\": 384,\n            \"style\": self.spacy_style,\n            \"map_location\": map_location,\n        }\n\n    def _prepare_pipeline(self) -&gt; Language:\n        \"\"\"Prepare the spacy pipeline.\n\n        Prepares the pipeline for processing the text in the corresponding\n        provided language.\n\n        Returns:\n            The spacy text processing and extraction pipeline.\n\n        \"\"\"\n\n        # load the appropriate parser for the language\n        module_lang, class_lang = self.lang[0].lower(), self.lang[1].lower().title()\n        language_module = importlib.import_module(f\"spacy.lang.{module_lang}\")\n        language_class = getattr(language_module, class_lang)\n        # initialize the language parser\n        nlp = language_class()\n        nlp.add_pipe(\"sentencizer\")\n        gliner_config = self._create_gliner_config()\n        nlp.add_pipe(\"gliner_spacy\", config=gliner_config)\n        return nlp\n\n    def _prepare_entities(self, doc: Doc) -&gt; Tuple[List[Entity], List[Span]]:\n        \"\"\"Prepares the anonipy and spacy entities.\n\n        Args:\n            doc: The spacy doc to prepare.\n\n        Returns:\n            The list of anonipy entities.\n            The list of spacy entities.\n\n        \"\"\"\n\n        # TODO: make this part more generic\n        anoni_entities = []\n        spacy_entities = []\n        for s in get_doc_entity_spans(doc, self.spacy_style):\n            label = list(filter(lambda x: x[\"label\"] == s.label_, self.labels))[0]\n            if re.match(label[\"regex\"], s.text):\n                anoni_entities.append(convert_spacy_to_entity(s, **label))\n                spacy_entities.append(s)\n        return anoni_entities, spacy_entities\n</code></pre>"},{"location":"references/anonymize/extractors/#anonipy.anonymize.extractors.NERExtractor.__init__","title":"<code>__init__(labels, *args, lang=LANGUAGES.ENGLISH, score_th=0.5, use_gpu=False, gliner_model='E3-JSI/gliner-multi-pii-domains-v1', spacy_style='ent', **kwargs)</code>","text":"<p>Initialize the named entity recognition (NER) extractor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.constants import LANGUAGES\n&gt;&gt;&gt; from anonipy.anonymize.extractors import NERExtractor\n&gt;&gt;&gt; labels = [{\"label\": \"PERSON\", \"type\": \"string\"}]\n&gt;&gt;&gt; extractor = NERExtractor(labels, lang=LANGUAGES.ENGLISH)\nNERExtractor()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>List[dict]</code> <p>The list of labels to extract.</p> required <code>lang</code> <code>LANGUAGES</code> <p>The language of the text to extract.</p> <code>ENGLISH</code> <code>score_th</code> <code>float</code> <p>The score threshold. Entities with a score below this threshold will be ignored.</p> <code>0.5</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use GPU.</p> <code>False</code> <code>gliner_model</code> <code>str</code> <p>The gliner model to use to identify the entities.</p> <code>'E3-JSI/gliner-multi-pii-domains-v1'</code> <code>spacy_style</code> <code>str</code> <p>The style the entities should be stored in the spacy doc. Options: <code>ent</code> or <code>span</code>.</p> <code>'ent'</code> Source code in <code>anonipy/anonymize/extractors/ner_extractor.py</code> <pre><code>def __init__(\n    self,\n    labels: List[dict],\n    *args,\n    lang: LANGUAGES = LANGUAGES.ENGLISH,\n    score_th: float = 0.5,\n    use_gpu: bool = False,\n    gliner_model: str = \"E3-JSI/gliner-multi-pii-domains-v1\",\n    spacy_style: str = \"ent\",\n    **kwargs,\n):\n    \"\"\"Initialize the named entity recognition (NER) extractor.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.constants import LANGUAGES\n        &gt;&gt;&gt; from anonipy.anonymize.extractors import NERExtractor\n        &gt;&gt;&gt; labels = [{\"label\": \"PERSON\", \"type\": \"string\"}]\n        &gt;&gt;&gt; extractor = NERExtractor(labels, lang=LANGUAGES.ENGLISH)\n        NERExtractor()\n\n    Args:\n        labels: The list of labels to extract.\n        lang: The language of the text to extract.\n        score_th: The score threshold. Entities with a score below this threshold will be ignored.\n        use_gpu: Whether to use GPU.\n        gliner_model: The gliner model to use to identify the entities.\n        spacy_style: The style the entities should be stored in the spacy doc. Options: `ent` or `span`.\n\n    \"\"\"\n\n    super().__init__(labels, *args, **kwargs)\n    self.lang = lang\n    self.score_th = score_th\n    self.use_gpu = use_gpu\n    self.gliner_model = gliner_model\n    self.spacy_style = spacy_style\n    self.labels = self._prepare_labels(labels)\n\n    with warnings.catch_warnings():\n        # TODO: remove once the GLiNER package includes the fix (inproper file closing)\n        warnings.filterwarnings(\"ignore\", category=ResourceWarning)\n        self.pipeline = self._prepare_pipeline()\n</code></pre>"},{"location":"references/anonymize/extractors/#anonipy.anonymize.extractors.NERExtractor.__call__","title":"<code>__call__(text, detect_repeats=False, *args, **kwargs)</code>","text":"<p>Extract the entities from the text.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; extractor(\"John Doe is a 19 year old software engineer.\", detect_repeats=False)\nDoc, [Entity]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to extract entities from.</p> required <code>detect_repeats</code> <code>bool</code> <p>Whether to check text again for repeated entities.</p> <code>False</code> <p>Returns:</p> Type Description <code>Doc</code> <p>The spacy document.</p> <code>List[Entity]</code> <p>The list of extracted entities.</p> Source code in <code>anonipy/anonymize/extractors/ner_extractor.py</code> <pre><code>def __call__(\n    self, text: str, detect_repeats: bool = False, *args, **kwargs\n) -&gt; Tuple[Doc, List[Entity]]:\n    \"\"\"Extract the entities from the text.\n\n    Examples:\n        &gt;&gt;&gt; extractor(\"John Doe is a 19 year old software engineer.\", detect_repeats=False)\n        Doc, [Entity]\n\n    Args:\n        text: The text to extract entities from.\n        detect_repeats: Whether to check text again for repeated entities.\n\n    Returns:\n        The spacy document.\n        The list of extracted entities.\n\n    \"\"\"\n\n    doc = self.pipeline(text)\n    anoni_entities, spacy_entities = self._prepare_entities(doc)\n\n    if detect_repeats:\n        anoni_entities = detect_repeated_entities(\n            doc, anoni_entities, self.spacy_style\n        )\n\n    create_spacy_entities(doc, anoni_entities, self.spacy_style)\n\n    return doc, anoni_entities\n</code></pre>"},{"location":"references/anonymize/extractors/#anonipy.anonymize.extractors.NERExtractor.display","title":"<code>display(doc, page=False, jupyter=None)</code>","text":"<p>Display the entities in the text.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; doc, entities = extractor(\"John Doe is a 19 year old software engineer.\")\n&gt;&gt;&gt; extractor.display(doc)\nHTML\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>doc</code> <code>Doc</code> <p>The spacy doc to display.</p> required <code>page</code> <code>bool</code> <p>Whether to display the doc in a web browser.</p> <code>False</code> <code>jupyter</code> <code>bool</code> <p>Whether to display the doc in a jupyter notebook.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML representation of the document and the extracted entities.</p> Source code in <code>anonipy/anonymize/extractors/ner_extractor.py</code> <pre><code>def display(self, doc: Doc, page: bool = False, jupyter: bool = None) -&gt; str:\n    \"\"\"Display the entities in the text.\n\n    Examples:\n        &gt;&gt;&gt; doc, entities = extractor(\"John Doe is a 19 year old software engineer.\")\n        &gt;&gt;&gt; extractor.display(doc)\n        HTML\n\n    Args:\n        doc: The spacy doc to display.\n        page: Whether to display the doc in a web browser.\n        jupyter: Whether to display the doc in a jupyter notebook.\n\n    Returns:\n        The HTML representation of the document and the extracted entities.\n\n    \"\"\"\n\n    options = {\n        \"colors\": {l[\"label\"]: get_label_color(l[\"label\"]) for l in self.labels}\n    }\n    return displacy.render(\n        doc, style=self.spacy_style, options=options, page=page, jupyter=jupyter\n    )\n</code></pre>"},{"location":"references/anonymize/extractors/#anonipy.anonymize.extractors.PatternExtractor","title":"<code>anonipy.anonymize.extractors.PatternExtractor</code>","text":"<p>               Bases: <code>ExtractorInterface</code></p> <p>The class representing the pattern extractor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.constants import LANGUAGES\n&gt;&gt;&gt; from anonipy.anonymize.extractors import PatternExtractor\n&gt;&gt;&gt; labels = [{\"label\": \"PERSON\", \"type\": \"string\", \"regex\": \"([A-Z][a-z]+ [A-Z][a-z]+)\"}]\n&gt;&gt;&gt; extractor = PatternExtractor(labels, lang=LANGUAGES.ENGLISH)\n&gt;&gt;&gt; extractor(\"John Doe is a 19 year old software engineer.\", detect_repeats=False)\nDoc, [Entity]\n</code></pre> <p>Attributes:</p> Name Type Description <code>labels</code> <code>List[dict]</code> <p>The list of labels and patterns to extract.</p> <code>lang</code> <code>str</code> <p>The language of the text to extract.</p> <code>pipeline</code> <code>Language</code> <p>The spacy pipeline for extracting entities.</p> <code>token_matchers</code> <code>Matcher</code> <p>The spacy token pattern matcher.</p> <code>global_matchers</code> <code>function</code> <p>The global pattern matcher.</p> <p>Methods:</p> Name Description <code>__call__</code> <p>Extract the entities from the text.</p> <code>display</code> <p>Display the entities in the text.</p> Source code in <code>anonipy/anonymize/extractors/pattern_extractor.py</code> <pre><code>class PatternExtractor(ExtractorInterface):\n    \"\"\"The class representing the pattern extractor.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.constants import LANGUAGES\n        &gt;&gt;&gt; from anonipy.anonymize.extractors import PatternExtractor\n        &gt;&gt;&gt; labels = [{\"label\": \"PERSON\", \"type\": \"string\", \"regex\": \"([A-Z][a-z]+ [A-Z][a-z]+)\"}]\n        &gt;&gt;&gt; extractor = PatternExtractor(labels, lang=LANGUAGES.ENGLISH)\n        &gt;&gt;&gt; extractor(\"John Doe is a 19 year old software engineer.\", detect_repeats=False)\n        Doc, [Entity]\n\n    Attributes:\n        labels (List[dict]): The list of labels and patterns to extract.\n        lang (str): The language of the text to extract.\n        pipeline (Language): The spacy pipeline for extracting entities.\n        token_matchers (Matcher): The spacy token pattern matcher.\n        global_matchers (function): The global pattern matcher.\n\n    Methods:\n        __call__(self, text):\n            Extract the entities from the text.\n        display(self, doc):\n            Display the entities in the text.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        labels: List[dict],\n        *args,\n        lang: LANGUAGES = LANGUAGES.ENGLISH,\n        spacy_style: str = \"ent\",\n        **kwargs,\n    ):\n        \"\"\"Initialize the pattern extractor.\n\n        Examples:\n            &gt;&gt;&gt; from anonipy.constants import LANGUAGES\n            &gt;&gt;&gt; from anonipy.anonymize.extractors import PatternExtractor\n            &gt;&gt;&gt; labels = [{\"label\": \"PERSON\", \"type\": \"string\", \"regex\": \"([A-Z][a-z]+ [A-Z][a-z]+)\"}]\n            &gt;&gt;&gt; extractor = PatternExtractor(labels, lang=LANGUAGES.ENGLISH)\n            PatternExtractor()\n\n        Args:\n            labels: The list of labels and patterns to extract.\n            lang: The language of the text to extract.\n            spacy_style: The style the entities should be stored in the spacy doc. Options: `ent` or `span`.\n\n        \"\"\"\n\n        super().__init__(labels, *args, **kwargs)\n        self.lang = lang\n        self.labels = labels\n        self.spacy_style = spacy_style\n        self.pipeline = self._prepare_pipeline()\n        self.token_matchers = self._prepare_token_matchers()\n        self.global_matchers = self._prepare_global_matchers()\n\n    def __call__(\n        self, text: str, detect_repeats: bool = False, *args, **kwargs\n    ) -&gt; Tuple[Doc, List[Entity]]:\n        \"\"\"Extract the entities from the text.\n\n        Examples:\n            &gt;&gt;&gt; extractor(\"John Doe is a 19 year old software engineer.\", detect_repeats=False)\n            Doc, [Entity]\n\n        Args:\n            text: The text to extract entities from.\n            detect_repeats: Whether to check text again for repeated entities.\n\n        Returns:\n            The spacy document.\n            The list of extracted entities.\n\n        \"\"\"\n\n        doc = self.pipeline(text)\n        self.token_matchers(doc) if self.token_matchers else None\n        self.global_matchers(doc) if self.global_matchers else None\n        anoni_entities, spacy_entities = self._prepare_entities(doc)\n\n        if detect_repeats:\n            anoni_entities = detect_repeated_entities(\n                doc, anoni_entities, self.spacy_style\n            )\n\n        create_spacy_entities(doc, anoni_entities, self.spacy_style)\n\n        return doc, anoni_entities\n\n    def display(self, doc: Doc, page: bool = False, jupyter: bool = None) -&gt; str:\n        \"\"\"Display the entities in the text.\n\n        Examples:\n            &gt;&gt;&gt; doc, entities = extractor(\"John Doe is a 19 year old software engineer.\")\n            &gt;&gt;&gt; extractor.display(doc)\n            HTML\n\n        Args:\n            doc: The spacy doc to display.\n            page: Whether to display the doc in a web browser.\n            jupyter: Whether to display the doc in a jupyter notebook.\n\n        Returns:\n            The HTML representation of the document and the extracted entities.\n\n        \"\"\"\n\n        options = {\n            \"colors\": {l[\"label\"]: get_label_color(l[\"label\"]) for l in self.labels}\n        }\n        return displacy.render(\n            doc, style=self.spacy_style, options=options, page=page, jupyter=jupyter\n        )\n\n    # ===========================================\n    # Private methods\n    # ===========================================\n\n    def _prepare_pipeline(self) -&gt; Language:\n        \"\"\"Prepare the spacy pipeline.\n\n        Prepares the pipeline for processing the text in the corresponding\n        provided language.\n\n        Returns:\n            The spacy text processing and extraction pipeline.\n\n        \"\"\"\n\n        # load the appropriate parser for the language\n        module_lang, class_lang = self.lang[0].lower(), self.lang[1].lower().title()\n        language_module = importlib.import_module(f\"spacy.lang.{module_lang}\")\n        language_class = getattr(language_module, class_lang)\n        # initialize the language parser\n        nlp = language_class()\n        nlp.add_pipe(\"sentencizer\")\n        return nlp\n\n    def _prepare_token_matchers(self) -&gt; Optional[Matcher]:\n        \"\"\"Prepare the token pattern matchers.\n\n        Prepares the token pattern matchers for the provided labels.\n\n        Returns:\n            The spacy matcher object or None if no relevant labels are provided.\n\n        \"\"\"\n\n        relevant_labels = list(filter(lambda l: \"pattern\" in l, self.labels))\n        if len(relevant_labels) == 0:\n            return None\n\n        matcher = Matcher(self.pipeline.vocab)\n        for label in relevant_labels:\n            if isinstance(label[\"pattern\"], list):\n                on_match = self._create_add_event_ent(label[\"label\"])\n                matcher.add(label[\"label\"], label[\"pattern\"], on_match=on_match)\n        return matcher\n\n    def _prepare_global_matchers(self) -&gt; Optional[Callable]:\n        \"\"\"Prepares the global pattern matchers.\n\n        Prepares the global pattern matchers for the provided labels.\n\n        Returns:\n            The function used to match the patterns or None if no relevant labels are provided.\n\n        \"\"\"\n\n        relevant_labels = list(filter(lambda l: \"regex\" in l, self.labels))\n        if len(relevant_labels) == 0:\n            return None\n\n        def global_matchers(doc: Doc) -&gt; None:\n            for label in relevant_labels:\n                for match in re.finditer(label[\"regex\"], doc.text):\n                    # define the entity span\n                    start, end = match.span(1)\n                    entity = doc.char_span(start, end, label=label[\"label\"])\n                    if not entity:\n                        continue\n                    entity._.score = 1.0\n                    entities = [convert_spacy_to_entity(entity)]\n                    # add the entity to the previous entity list\n                    create_spacy_entities(doc, entities, self.spacy_style)\n\n        return global_matchers\n\n    def _prepare_entities(self, doc: Doc) -&gt; Tuple[List[Entity], List[Span]]:\n        \"\"\"Prepares the anonipy and spacy entities.\n\n        Args:\n            doc: The spacy doc to prepare.\n\n        Returns:\n            The list of anonipy entities.\n            The list of spacy entities.\n\n        \"\"\"\n\n        # TODO: make this part more generic\n        anoni_entities = []\n        spacy_entities = []\n        for e in get_doc_entity_spans(doc, self.spacy_style):\n            label = list(filter(lambda x: x[\"label\"] == e.label_, self.labels))[0]\n            anoni_entities.append(convert_spacy_to_entity(e, **label))\n            spacy_entities.append(e)\n        return anoni_entities, spacy_entities\n\n    def _create_add_event_ent(self, label: str) -&gt; Callable:\n        \"\"\"Create the add event entity function\n\n        Args:\n            label: The identified label entity.\n\n        Returns:\n            The function used to add the entity to the spacy doc.\n\n        \"\"\"\n\n        def add_event_ent(matcher, doc, i, matches):\n            # define the entity span\n            _, start, end = matches[i]\n            entity = Span(doc, start, end, label=label)\n            if not entity:\n                return\n            entity._.score = 1.0\n            entities = [convert_spacy_to_entity(entity)]\n            create_spacy_entities(doc, entities, self.spacy_style)\n\n        return add_event_ent\n</code></pre>"},{"location":"references/anonymize/extractors/#anonipy.anonymize.extractors.PatternExtractor.__init__","title":"<code>__init__(labels, *args, lang=LANGUAGES.ENGLISH, spacy_style='ent', **kwargs)</code>","text":"<p>Initialize the pattern extractor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.constants import LANGUAGES\n&gt;&gt;&gt; from anonipy.anonymize.extractors import PatternExtractor\n&gt;&gt;&gt; labels = [{\"label\": \"PERSON\", \"type\": \"string\", \"regex\": \"([A-Z][a-z]+ [A-Z][a-z]+)\"}]\n&gt;&gt;&gt; extractor = PatternExtractor(labels, lang=LANGUAGES.ENGLISH)\nPatternExtractor()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>List[dict]</code> <p>The list of labels and patterns to extract.</p> required <code>lang</code> <code>LANGUAGES</code> <p>The language of the text to extract.</p> <code>ENGLISH</code> <code>spacy_style</code> <code>str</code> <p>The style the entities should be stored in the spacy doc. Options: <code>ent</code> or <code>span</code>.</p> <code>'ent'</code> Source code in <code>anonipy/anonymize/extractors/pattern_extractor.py</code> <pre><code>def __init__(\n    self,\n    labels: List[dict],\n    *args,\n    lang: LANGUAGES = LANGUAGES.ENGLISH,\n    spacy_style: str = \"ent\",\n    **kwargs,\n):\n    \"\"\"Initialize the pattern extractor.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.constants import LANGUAGES\n        &gt;&gt;&gt; from anonipy.anonymize.extractors import PatternExtractor\n        &gt;&gt;&gt; labels = [{\"label\": \"PERSON\", \"type\": \"string\", \"regex\": \"([A-Z][a-z]+ [A-Z][a-z]+)\"}]\n        &gt;&gt;&gt; extractor = PatternExtractor(labels, lang=LANGUAGES.ENGLISH)\n        PatternExtractor()\n\n    Args:\n        labels: The list of labels and patterns to extract.\n        lang: The language of the text to extract.\n        spacy_style: The style the entities should be stored in the spacy doc. Options: `ent` or `span`.\n\n    \"\"\"\n\n    super().__init__(labels, *args, **kwargs)\n    self.lang = lang\n    self.labels = labels\n    self.spacy_style = spacy_style\n    self.pipeline = self._prepare_pipeline()\n    self.token_matchers = self._prepare_token_matchers()\n    self.global_matchers = self._prepare_global_matchers()\n</code></pre>"},{"location":"references/anonymize/extractors/#anonipy.anonymize.extractors.PatternExtractor.__call__","title":"<code>__call__(text, detect_repeats=False, *args, **kwargs)</code>","text":"<p>Extract the entities from the text.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; extractor(\"John Doe is a 19 year old software engineer.\", detect_repeats=False)\nDoc, [Entity]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to extract entities from.</p> required <code>detect_repeats</code> <code>bool</code> <p>Whether to check text again for repeated entities.</p> <code>False</code> <p>Returns:</p> Type Description <code>Doc</code> <p>The spacy document.</p> <code>List[Entity]</code> <p>The list of extracted entities.</p> Source code in <code>anonipy/anonymize/extractors/pattern_extractor.py</code> <pre><code>def __call__(\n    self, text: str, detect_repeats: bool = False, *args, **kwargs\n) -&gt; Tuple[Doc, List[Entity]]:\n    \"\"\"Extract the entities from the text.\n\n    Examples:\n        &gt;&gt;&gt; extractor(\"John Doe is a 19 year old software engineer.\", detect_repeats=False)\n        Doc, [Entity]\n\n    Args:\n        text: The text to extract entities from.\n        detect_repeats: Whether to check text again for repeated entities.\n\n    Returns:\n        The spacy document.\n        The list of extracted entities.\n\n    \"\"\"\n\n    doc = self.pipeline(text)\n    self.token_matchers(doc) if self.token_matchers else None\n    self.global_matchers(doc) if self.global_matchers else None\n    anoni_entities, spacy_entities = self._prepare_entities(doc)\n\n    if detect_repeats:\n        anoni_entities = detect_repeated_entities(\n            doc, anoni_entities, self.spacy_style\n        )\n\n    create_spacy_entities(doc, anoni_entities, self.spacy_style)\n\n    return doc, anoni_entities\n</code></pre>"},{"location":"references/anonymize/extractors/#anonipy.anonymize.extractors.PatternExtractor.display","title":"<code>display(doc, page=False, jupyter=None)</code>","text":"<p>Display the entities in the text.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; doc, entities = extractor(\"John Doe is a 19 year old software engineer.\")\n&gt;&gt;&gt; extractor.display(doc)\nHTML\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>doc</code> <code>Doc</code> <p>The spacy doc to display.</p> required <code>page</code> <code>bool</code> <p>Whether to display the doc in a web browser.</p> <code>False</code> <code>jupyter</code> <code>bool</code> <p>Whether to display the doc in a jupyter notebook.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML representation of the document and the extracted entities.</p> Source code in <code>anonipy/anonymize/extractors/pattern_extractor.py</code> <pre><code>def display(self, doc: Doc, page: bool = False, jupyter: bool = None) -&gt; str:\n    \"\"\"Display the entities in the text.\n\n    Examples:\n        &gt;&gt;&gt; doc, entities = extractor(\"John Doe is a 19 year old software engineer.\")\n        &gt;&gt;&gt; extractor.display(doc)\n        HTML\n\n    Args:\n        doc: The spacy doc to display.\n        page: Whether to display the doc in a web browser.\n        jupyter: Whether to display the doc in a jupyter notebook.\n\n    Returns:\n        The HTML representation of the document and the extracted entities.\n\n    \"\"\"\n\n    options = {\n        \"colors\": {l[\"label\"]: get_label_color(l[\"label\"]) for l in self.labels}\n    }\n    return displacy.render(\n        doc, style=self.spacy_style, options=options, page=page, jupyter=jupyter\n    )\n</code></pre>"},{"location":"references/anonymize/extractors/#anonipy.anonymize.extractors.MultiExtractor","title":"<code>anonipy.anonymize.extractors.MultiExtractor</code>","text":"<p>The class representing the multi extractor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.constants import LANGUAGES\n&gt;&gt;&gt; from anonipy.anonymize.extractors import NERExtractor, PatternExtractor, MultiExtractor\n&gt;&gt;&gt; extractors = [\n&gt;&gt;&gt;     NERExtractor(ner_labels, lang=LANGUAGES.ENGLISH),\n&gt;&gt;&gt;     PatternExtractor(pattern_labels, lang=LANGUAGES.ENGLISH),\n&gt;&gt;&gt; ]\n&gt;&gt;&gt; extractor = MultiExtractor(extractors)\n&gt;&gt;&gt; extractor(\"John Doe is a 19 year old software engineer.\", detect_repeats=False)\n[(Doc, [Entity]), (Doc, [Entity])], [Entity]\n</code></pre> <p>Attributes:</p> Name Type Description <code>extractors</code> <code>List[ExtractorInterface]</code> <p>The list of extractors to use.</p> <p>Methods:</p> Name Description <code>__call__</code> <p>Extract the entities fron the text using the provided extractors.</p> <code>display</code> <p>Display the entities extracted from the text document.</p> Source code in <code>anonipy/anonymize/extractors/multi_extractor.py</code> <pre><code>class MultiExtractor:\n    \"\"\"The class representing the multi extractor.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.constants import LANGUAGES\n        &gt;&gt;&gt; from anonipy.anonymize.extractors import NERExtractor, PatternExtractor, MultiExtractor\n        &gt;&gt;&gt; extractors = [\n        &gt;&gt;&gt;     NERExtractor(ner_labels, lang=LANGUAGES.ENGLISH),\n        &gt;&gt;&gt;     PatternExtractor(pattern_labels, lang=LANGUAGES.ENGLISH),\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; extractor = MultiExtractor(extractors)\n        &gt;&gt;&gt; extractor(\"John Doe is a 19 year old software engineer.\", detect_repeats=False)\n        [(Doc, [Entity]), (Doc, [Entity])], [Entity]\n\n    Attributes:\n        extractors (List[ExtractorInterface]):\n            The list of extractors to use.\n\n    Methods:\n        __call__(self, text):\n            Extract the entities fron the text using the provided extractors.\n        display(self, doc):\n            Display the entities extracted from the text document.\n\n    \"\"\"\n\n    def __init__(self, extractors: List[ExtractorInterface]):\n        \"\"\"Initialize the multi extractor.\n\n        Examples:\n            &gt;&gt;&gt; from anonipy.constants import LANGUAGES\n            &gt;&gt;&gt; from anonipy.anonymize.extractors import NERExtractor, PatternExtractor, MultiExtractor\n            &gt;&gt;&gt; extractors = [\n            &gt;&gt;&gt;     NERExtractor(ner_labels, lang=LANGUAGES.ENGLISH),\n            &gt;&gt;&gt;     PatternExtractor(pattern_labels, lang=LANGUAGES.ENGLISH),\n            &gt;&gt;&gt; ]\n            &gt;&gt;&gt; extractor = MultiExtractor(extractors)\n            MultiExtractor()\n\n        Args:\n            extractors: The list of extractors to use.\n\n        \"\"\"\n        if len(extractors) == 0:\n            raise ValueError(\"At least one extractor must be provided.\")\n        if not all(isinstance(e, ExtractorInterface) for e in extractors):\n            raise ValueError(\"All extractors must be instances of ExtractorInterface.\")\n\n        self.extractors = extractors\n\n    def __call__(\n        self, text: str, detect_repeats: bool = False\n    ) -&gt; Tuple[List[Tuple[Doc, List[Entity]]], List[Entity]]:\n        \"\"\"Extract the entities fron the text using the provided extractors.\n\n        Examples:\n            &gt;&gt;&gt; extractor(\"John Doe is a 19 year old software engineer.\", detect_repeats=False)\n            [(Doc, [Entity]), (Doc, [Entity])], [Entity]\n\n        Args:\n            text: The text to extract entities from.\n            detect_repeats: Whether to check text again for repeated entities.\n\n        Returns:\n            The list of extractor outputs containing the tuple (spacy document, extracted entities).\n            The list of joint entities.\n\n        \"\"\"\n\n        extractor_outputs = [e(text, detect_repeats) for e in self.extractors]\n        joint_entities = merge_entities(extractor_outputs)\n\n        return extractor_outputs, joint_entities\n\n    def display(self, doc: Doc, page: bool = False, jupyter: bool = None) -&gt; str:\n        \"\"\"Display the entities in the text.\n\n        Examples:\n            &gt;&gt;&gt; extractor_outputs, entities = extractor(\"John Doe is a 19 year old software engineer.\")\n            &gt;&gt;&gt; extractor.display(extractor_outputs[0][0])\n            HTML\n\n        Args:\n            doc: The spacy doc to display.\n            page: Whether to display the doc in a web browser.\n            jupyter: Whether to display the doc in a jupyter notebook.\n\n        Returns:\n            The HTML representation of the document and the extracted entities.\n\n        \"\"\"\n\n        labels = list(\n            itertools.chain.from_iterable([e.labels for e in self.extractors])\n        )\n        options = {\"colors\": {l[\"label\"]: get_label_color(l[\"label\"]) for l in labels}}\n        return displacy.render(\n            doc, style=\"ent\", options=options, page=page, jupyter=jupyter\n        )\n</code></pre>"},{"location":"references/anonymize/extractors/#anonipy.anonymize.extractors.MultiExtractor.__init__","title":"<code>__init__(extractors)</code>","text":"<p>Initialize the multi extractor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.constants import LANGUAGES\n&gt;&gt;&gt; from anonipy.anonymize.extractors import NERExtractor, PatternExtractor, MultiExtractor\n&gt;&gt;&gt; extractors = [\n&gt;&gt;&gt;     NERExtractor(ner_labels, lang=LANGUAGES.ENGLISH),\n&gt;&gt;&gt;     PatternExtractor(pattern_labels, lang=LANGUAGES.ENGLISH),\n&gt;&gt;&gt; ]\n&gt;&gt;&gt; extractor = MultiExtractor(extractors)\nMultiExtractor()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>extractors</code> <code>List[ExtractorInterface]</code> <p>The list of extractors to use.</p> required Source code in <code>anonipy/anonymize/extractors/multi_extractor.py</code> <pre><code>def __init__(self, extractors: List[ExtractorInterface]):\n    \"\"\"Initialize the multi extractor.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.constants import LANGUAGES\n        &gt;&gt;&gt; from anonipy.anonymize.extractors import NERExtractor, PatternExtractor, MultiExtractor\n        &gt;&gt;&gt; extractors = [\n        &gt;&gt;&gt;     NERExtractor(ner_labels, lang=LANGUAGES.ENGLISH),\n        &gt;&gt;&gt;     PatternExtractor(pattern_labels, lang=LANGUAGES.ENGLISH),\n        &gt;&gt;&gt; ]\n        &gt;&gt;&gt; extractor = MultiExtractor(extractors)\n        MultiExtractor()\n\n    Args:\n        extractors: The list of extractors to use.\n\n    \"\"\"\n    if len(extractors) == 0:\n        raise ValueError(\"At least one extractor must be provided.\")\n    if not all(isinstance(e, ExtractorInterface) for e in extractors):\n        raise ValueError(\"All extractors must be instances of ExtractorInterface.\")\n\n    self.extractors = extractors\n</code></pre>"},{"location":"references/anonymize/extractors/#anonipy.anonymize.extractors.MultiExtractor.__call__","title":"<code>__call__(text, detect_repeats=False)</code>","text":"<p>Extract the entities fron the text using the provided extractors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; extractor(\"John Doe is a 19 year old software engineer.\", detect_repeats=False)\n[(Doc, [Entity]), (Doc, [Entity])], [Entity]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to extract entities from.</p> required <code>detect_repeats</code> <code>bool</code> <p>Whether to check text again for repeated entities.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Tuple[Doc, List[Entity]]]</code> <p>The list of extractor outputs containing the tuple (spacy document, extracted entities).</p> <code>List[Entity]</code> <p>The list of joint entities.</p> Source code in <code>anonipy/anonymize/extractors/multi_extractor.py</code> <pre><code>def __call__(\n    self, text: str, detect_repeats: bool = False\n) -&gt; Tuple[List[Tuple[Doc, List[Entity]]], List[Entity]]:\n    \"\"\"Extract the entities fron the text using the provided extractors.\n\n    Examples:\n        &gt;&gt;&gt; extractor(\"John Doe is a 19 year old software engineer.\", detect_repeats=False)\n        [(Doc, [Entity]), (Doc, [Entity])], [Entity]\n\n    Args:\n        text: The text to extract entities from.\n        detect_repeats: Whether to check text again for repeated entities.\n\n    Returns:\n        The list of extractor outputs containing the tuple (spacy document, extracted entities).\n        The list of joint entities.\n\n    \"\"\"\n\n    extractor_outputs = [e(text, detect_repeats) for e in self.extractors]\n    joint_entities = merge_entities(extractor_outputs)\n\n    return extractor_outputs, joint_entities\n</code></pre>"},{"location":"references/anonymize/extractors/#anonipy.anonymize.extractors.MultiExtractor.display","title":"<code>display(doc, page=False, jupyter=None)</code>","text":"<p>Display the entities in the text.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; extractor_outputs, entities = extractor(\"John Doe is a 19 year old software engineer.\")\n&gt;&gt;&gt; extractor.display(extractor_outputs[0][0])\nHTML\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>doc</code> <code>Doc</code> <p>The spacy doc to display.</p> required <code>page</code> <code>bool</code> <p>Whether to display the doc in a web browser.</p> <code>False</code> <code>jupyter</code> <code>bool</code> <p>Whether to display the doc in a jupyter notebook.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML representation of the document and the extracted entities.</p> Source code in <code>anonipy/anonymize/extractors/multi_extractor.py</code> <pre><code>def display(self, doc: Doc, page: bool = False, jupyter: bool = None) -&gt; str:\n    \"\"\"Display the entities in the text.\n\n    Examples:\n        &gt;&gt;&gt; extractor_outputs, entities = extractor(\"John Doe is a 19 year old software engineer.\")\n        &gt;&gt;&gt; extractor.display(extractor_outputs[0][0])\n        HTML\n\n    Args:\n        doc: The spacy doc to display.\n        page: Whether to display the doc in a web browser.\n        jupyter: Whether to display the doc in a jupyter notebook.\n\n    Returns:\n        The HTML representation of the document and the extracted entities.\n\n    \"\"\"\n\n    labels = list(\n        itertools.chain.from_iterable([e.labels for e in self.extractors])\n    )\n    options = {\"colors\": {l[\"label\"]: get_label_color(l[\"label\"]) for l in labels}}\n    return displacy.render(\n        doc, style=\"ent\", options=options, page=page, jupyter=jupyter\n    )\n</code></pre>"},{"location":"references/anonymize/extractors/#anonipy.anonymize.extractors.ExtractorInterface","title":"<code>anonipy.anonymize.extractors.ExtractorInterface</code>","text":"<p>The class representing the extractor interface.</p> <p>All extractors should inherit from this class.</p> <p>Methods:</p> Name Description <code>__call__</code> <p>Extract entities from the text.</p> Source code in <code>anonipy/anonymize/extractors/interface.py</code> <pre><code>class ExtractorInterface:\n    \"\"\"The class representing the extractor interface.\n\n    All extractors should inherit from this class.\n\n    Methods:\n        __call__(text):\n            Extract entities from the text.\n\n    \"\"\"\n\n    def __init__(self, labels: List[dict], *args, **kwargs):\n        pass\n\n    def __call__(self, text: str, *args, **kwargs) -&gt; Tuple[Doc, List[Entity]]:\n        pass\n</code></pre>"},{"location":"references/anonymize/generators/","title":"Generators Module","text":""},{"location":"references/anonymize/generators/#anonipy.anonymize.generators","title":"<code>anonipy.anonymize.generators</code>","text":"<p>Module containing the <code>generators</code>.</p> <p>The <code>generators</code> module provides a set of generators used to generate data substitutes.</p> <p>Classes:</p> Name Description <code>LLMLabelGenerator</code> <p>The class representing the label generator utilizing LLMs.</p> <code>MaskLabelGenerator</code> <p>The class representing the label generator utilizing token masking.</p> <code>NumberGenerator</code> <p>The class representing the number generator.</p> <code>DateGenerator</code> <p>The class representing the date generator.</p>"},{"location":"references/anonymize/generators/#anonipy.anonymize.generators.LLMLabelGenerator","title":"<code>anonipy.anonymize.generators.LLMLabelGenerator</code>","text":"<p>               Bases: <code>GeneratorInterface</code></p> <p>The class representing the LLM label generator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.generators import LLMLabelGenerator\n&gt;&gt;&gt; generator = LLMLabelGenerator()\n&gt;&gt;&gt; generator.generate(entity)\n</code></pre> <p>Attributes:</p> Name Type Description <code>model</code> <code>Transformers</code> <p>The model used to generate the label substitutes.</p> <p>Methods:</p> Name Description <code>generate</code> <p>Generate the label based on the entity.</p> Source code in <code>anonipy/anonymize/generators/llm_label_generator.py</code> <pre><code>class LLMLabelGenerator(GeneratorInterface):\n    \"\"\"The class representing the LLM label generator.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.generators import LLMLabelGenerator\n        &gt;&gt;&gt; generator = LLMLabelGenerator()\n        &gt;&gt;&gt; generator.generate(entity)\n\n    Attributes:\n        model (models.Transformers): The model used to generate the label substitutes.\n\n    Methods:\n        generate(entity, entity_prefix, temperature):\n            Generate the label based on the entity.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        *args,\n        model_name: str = \"HuggingFaceTB/SmolLM2-1.7B-Instruct\",\n        use_gpu: bool = False,\n        use_quant: bool = False,\n        **kwargs,\n    ):\n        \"\"\"Initializes the LLM label generator.\n\n        Args:\n            model_name: The name of the model to use.\n            use_gpu: Whether to use GPU or not.\n            use_quant: Whether to use quantization or not.\n\n        Examples:\n            &gt;&gt;&gt; from anonipy.anonymize.generators import LLMLabelGenerator\n            &gt;&gt;&gt; generator = LLMLabelGenerator()\n            LLMLabelGenerator()\n\n        \"\"\"\n\n        super().__init__(*args, **kwargs)\n\n        if use_gpu and not torch.cuda.is_available():\n            warnings.warn(\n                \"The use_gpu=True flag requires GPU/CUDA, but it is not available. Setting use_gpu=False.\"\n            )\n            use_gpu = False\n\n        if use_quant and not is_installed_with([\"quant\", \"all\"]):\n            warnings.warn(\n                \"The use_quant=True flag requires the 'quant' extra dependencies, but they are not installed. Setting use_quant=False.\"\n            )\n            use_quant = False\n\n        self.model, self.tokenizer = self._prepare_model_and_tokenizer(\n            model_name, use_gpu, use_quant\n        )\n\n    def generate(\n        self,\n        entity: Entity,\n        *args,\n        add_entity_attrs: str = \"\",\n        temperature: float = 1.0,\n        top_p: float = 0.95,\n        **kwargs,\n    ) -&gt; str:\n        \"\"\"Generate the substitute for the entity based on it's attributes.\n\n        Examples:\n            &gt;&gt;&gt; from anonipy.anonymize.generators import LLMLabelGenerator\n            &gt;&gt;&gt; generator = LLMLabelGenerator()\n            &gt;&gt;&gt; generator.generate(entity)\n            label\n\n        Args:\n            entity: The entity to generate the label from.\n            add_entity_attrs: Additional entity attribute description to add to the generation.\n            temperature: The temperature to use for the generation.\n            top_p: The top p to use for the generation.\n\n        Returns:\n            The generated entity label substitute.\n\n        \"\"\"\n\n        message = [\n            {\n                \"role\": \"system\",\n                \"content\": \"You are a helpful AI assistant for generating replacements for text entities.\",\n            },\n            {\n                \"role\": \"user\",\n                \"content\": f\"What is a random {add_entity_attrs} {entity.label} replacement for {entity.text}? Respond only with the replacement.\",\n            },\n        ]\n        return self._generate_response(message, temperature, top_p)\n\n    # =================================\n    # Private methods\n    # =================================\n\n    def _prepare_model_and_tokenizer(\n        self, model_name: str, use_gpu: bool, use_quant: bool\n    ) -&gt; Tuple[AutoModelForCausalLM, AutoTokenizer]:\n        \"\"\"Prepares the model and tokenizer.\n\n        Args:\n            model_name: The name of the model to use.\n\n        Returns:\n            The huggingface model.\n            The huggingface tokenizer.\n\n        \"\"\"\n\n        # prepare the model\n        device = torch.device(\n            \"cuda\" if use_gpu and torch.cuda.is_available() else \"cpu\"\n        )\n        dtype = torch.float32 if device.type == \"cpu\" else torch.float16\n\n        model = self._load_model(model_name, device, dtype, use_quant, use_gpu)\n        tokenizer = self._load_tokenizer(model_name)\n\n        return model, tokenizer\n\n    def _load_model(\n        self,\n        model_name: str,\n        device: torch.device,\n        dtype: torch.dtype,\n        use_quant: bool,\n        use_gpu: bool,\n    ) -&gt; AutoModelForCausalLM:\n        \"\"\"Load the model with appropriate configuration.\n\n        Args:\n            model_name: The name of the model to use.\n            device: The device to use for the model.\n            dtype: The data type to use for the model.\n            use_quant: Whether to use quantization or not.\n            use_gpu: Whether to use GPU or not.\n\n        Returns:\n            The huggingface model.\n\n        \"\"\"\n        if use_quant and use_gpu:\n            quant_config = BitsAndBytesConfig(\n                load_in_8bit=True, bnb_4bit_compute_dtype=dtype\n            )\n            return AutoModelForCausalLM.from_pretrained(\n                model_name,\n                device_map=device,\n                torch_dtype=dtype,\n                quantization_config=quant_config,\n            )\n\n        if use_quant:\n            warnings.warn(\n                \"Quantization is only supported on GPU, but use_gpu=False. Loading model without quantization.\"\n            )\n\n        return AutoModelForCausalLM.from_pretrained(\n            model_name, device_map=device, torch_dtype=dtype\n        )\n\n    def _load_tokenizer(self, model_name: str) -&gt; AutoTokenizer:\n        \"\"\"Load the tokenizer with appropriate configuration.\n\n        Args:\n            model_name: The name of the model to use.\n\n        Returns:\n            The huggingface tokenizer.\n        \"\"\"\n        return AutoTokenizer.from_pretrained(\n            model_name, padding_side=\"right\", use_fast=False\n        )\n\n    def _generate_response(\n        self, message: List[dict], temperature: float, top_p: float\n    ) -&gt; str:\n        \"\"\"Generate the response from the LLM.\n\n        Args:\n            message: The message to generate the response from.\n            temperature: The temperature to use for the generation.\n            top_p: The top p to use for the generation.\n\n        Returns:\n            The generated response.\n\n        \"\"\"\n\n        # tokenize the message\n        input_ids = self.tokenizer.apply_chat_template(\n            message, tokenize=True, return_tensors=\"pt\", add_generation_prompt=True\n        ).to(self.model.device)\n\n        # create attention mask (1 for all tokens)\n        attention_mask = torch.ones_like(input_ids)\n\n        # set pad token id if not set\n        if self.tokenizer.pad_token_id is None:\n            self.tokenizer.pad_token_id = self.tokenizer.eos_token_id\n\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\"ignore\", message=\".*the `logits` model output.*\")\n\n            # generate the response\n            with torch.no_grad():\n                output_ids = self.model.generate(\n                    input_ids,\n                    attention_mask=attention_mask,\n                    max_new_tokens=50,\n                    temperature=temperature,\n                    top_p=top_p,\n                    do_sample=True,\n                    pad_token_id=self.tokenizer.pad_token_id,\n                )\n\n        # decode the response\n        response = self.tokenizer.decode(\n            output_ids[0][len(input_ids[0]) :], skip_special_tokens=True\n        )\n        return response\n</code></pre>"},{"location":"references/anonymize/generators/#anonipy.anonymize.generators.LLMLabelGenerator.__init__","title":"<code>__init__(*args, model_name='HuggingFaceTB/SmolLM2-1.7B-Instruct', use_gpu=False, use_quant=False, **kwargs)</code>","text":"<p>Initializes the LLM label generator.</p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>The name of the model to use.</p> <code>'HuggingFaceTB/SmolLM2-1.7B-Instruct'</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use GPU or not.</p> <code>False</code> <code>use_quant</code> <code>bool</code> <p>Whether to use quantization or not.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.generators import LLMLabelGenerator\n&gt;&gt;&gt; generator = LLMLabelGenerator()\nLLMLabelGenerator()\n</code></pre> Source code in <code>anonipy/anonymize/generators/llm_label_generator.py</code> <pre><code>def __init__(\n    self,\n    *args,\n    model_name: str = \"HuggingFaceTB/SmolLM2-1.7B-Instruct\",\n    use_gpu: bool = False,\n    use_quant: bool = False,\n    **kwargs,\n):\n    \"\"\"Initializes the LLM label generator.\n\n    Args:\n        model_name: The name of the model to use.\n        use_gpu: Whether to use GPU or not.\n        use_quant: Whether to use quantization or not.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.generators import LLMLabelGenerator\n        &gt;&gt;&gt; generator = LLMLabelGenerator()\n        LLMLabelGenerator()\n\n    \"\"\"\n\n    super().__init__(*args, **kwargs)\n\n    if use_gpu and not torch.cuda.is_available():\n        warnings.warn(\n            \"The use_gpu=True flag requires GPU/CUDA, but it is not available. Setting use_gpu=False.\"\n        )\n        use_gpu = False\n\n    if use_quant and not is_installed_with([\"quant\", \"all\"]):\n        warnings.warn(\n            \"The use_quant=True flag requires the 'quant' extra dependencies, but they are not installed. Setting use_quant=False.\"\n        )\n        use_quant = False\n\n    self.model, self.tokenizer = self._prepare_model_and_tokenizer(\n        model_name, use_gpu, use_quant\n    )\n</code></pre>"},{"location":"references/anonymize/generators/#anonipy.anonymize.generators.LLMLabelGenerator.generate","title":"<code>generate(entity, *args, add_entity_attrs='', temperature=1.0, top_p=0.95, **kwargs)</code>","text":"<p>Generate the substitute for the entity based on it's attributes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.generators import LLMLabelGenerator\n&gt;&gt;&gt; generator = LLMLabelGenerator()\n&gt;&gt;&gt; generator.generate(entity)\nlabel\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>Entity</code> <p>The entity to generate the label from.</p> required <code>add_entity_attrs</code> <code>str</code> <p>Additional entity attribute description to add to the generation.</p> <code>''</code> <code>temperature</code> <code>float</code> <p>The temperature to use for the generation.</p> <code>1.0</code> <code>top_p</code> <code>float</code> <p>The top p to use for the generation.</p> <code>0.95</code> <p>Returns:</p> Type Description <code>str</code> <p>The generated entity label substitute.</p> Source code in <code>anonipy/anonymize/generators/llm_label_generator.py</code> <pre><code>def generate(\n    self,\n    entity: Entity,\n    *args,\n    add_entity_attrs: str = \"\",\n    temperature: float = 1.0,\n    top_p: float = 0.95,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Generate the substitute for the entity based on it's attributes.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.generators import LLMLabelGenerator\n        &gt;&gt;&gt; generator = LLMLabelGenerator()\n        &gt;&gt;&gt; generator.generate(entity)\n        label\n\n    Args:\n        entity: The entity to generate the label from.\n        add_entity_attrs: Additional entity attribute description to add to the generation.\n        temperature: The temperature to use for the generation.\n        top_p: The top p to use for the generation.\n\n    Returns:\n        The generated entity label substitute.\n\n    \"\"\"\n\n    message = [\n        {\n            \"role\": \"system\",\n            \"content\": \"You are a helpful AI assistant for generating replacements for text entities.\",\n        },\n        {\n            \"role\": \"user\",\n            \"content\": f\"What is a random {add_entity_attrs} {entity.label} replacement for {entity.text}? Respond only with the replacement.\",\n        },\n    ]\n    return self._generate_response(message, temperature, top_p)\n</code></pre>"},{"location":"references/anonymize/generators/#anonipy.anonymize.generators.MaskLabelGenerator","title":"<code>anonipy.anonymize.generators.MaskLabelGenerator</code>","text":"<p>               Bases: <code>GeneratorInterface</code></p> <p>The class representing the mask label generator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.generators import MaskLabelGenerator\n&gt;&gt;&gt; generator = MaskLabelGenerator(model_name, context_window=100, use_gpu=False)\n&gt;&gt;&gt; generator.generate(entity)\n</code></pre> <p>Attributes:</p> Name Type Description <code>pipeline</code> <code>Pipeline</code> <p>The transformers pipeline used to generate the label substitutes.</p> <code>context_window</code> <code>int</code> <p>The context window size to use to generate the label substitutes.</p> <code>mask_token</code> <code>str</code> <p>The mask token to use to replace the masked words.</p> <p>Methods:</p> Name Description <code>generate</code> <p>Generate the substitute for the entity based on it's location in the text.</p> Source code in <code>anonipy/anonymize/generators/mask_label_generator.py</code> <pre><code>class MaskLabelGenerator(GeneratorInterface):\n    \"\"\"The class representing the mask label generator.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.generators import MaskLabelGenerator\n        &gt;&gt;&gt; generator = MaskLabelGenerator(model_name, context_window=100, use_gpu=False)\n        &gt;&gt;&gt; generator.generate(entity)\n\n\n    Attributes:\n        pipeline (Pipeline): The transformers pipeline used to generate the label substitutes.\n        context_window (int): The context window size to use to generate the label substitutes.\n        mask_token (str): The mask token to use to replace the masked words.\n\n    Methods:\n        generate(entity, text):\n            Generate the substitute for the entity based on it's location in the text.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        *args,\n        model_name: str = \"FacebookAI/xlm-roberta-large\",\n        use_gpu: bool = False,\n        context_window: int = 100,\n        **kwargs,\n    ):\n        \"\"\"Initializes the mask label generator.\n\n        Examples:\n            &gt;&gt;&gt; from anonipy.anonymize.generators import MaskLabelGenerator\n            &gt;&gt;&gt; generator = MaskLabelGenerator(context_window=120, use_gpu=True)\n\n        Args:\n            model_name: The name of the masking model to use.\n            use_gpu: Whether to use GPU/CUDA, if available.\n            context_window: The context window size.\n\n        \"\"\"\n\n        super().__init__(*args, **kwargs)\n        self.context_window = context_window\n        if use_gpu and not torch.cuda.is_available():\n            warnings.warn(\n                \"The use_gpu=True flag requires GPU/CUDA, but it is not available. Setting use_gpu=False.\"\n            )\n            use_gpu = False\n\n        # prepare the fill-mask pipeline and store the mask token\n        model, tokenizer, device = self._prepare_model_and_tokenizer(\n            model_name, use_gpu\n        )\n        self.mask_token = tokenizer.mask_token\n        self.pipeline = pipeline(\n            \"fill-mask\", model=model, tokenizer=tokenizer, top_k=40, device=device\n        )\n\n    def generate(self, entity: Entity, text: str, *args, **kwargs) -&gt; str:\n        \"\"\"Generate the substitute for the entity using the masking model.\n\n        Examples:\n            &gt;&gt;&gt; from anonipy.anonymize.generators import MaskLabelGenerator\n            &gt;&gt;&gt; generator = MaskLabelGenerator(context_window=120, use_gpu=True)\n            &gt;&gt;&gt; generator.generate(entity, text)\n            label\n\n        Args:\n            entity: The entity used to generate the substitute.\n            text: The original text in which the entity is located; used to get the entity's context.\n\n        Returns:\n            The generated substitute text.\n\n        \"\"\"\n\n        masks = self._create_masks(entity)\n        input_texts = self._prepare_generate_inputs(masks, text)\n        suggestions = self.pipeline(input_texts)\n        return self._create_substitute(entity, masks, suggestions)\n\n    # =================================\n    # Private methods\n    # =================================\n\n    def _prepare_model_and_tokenizer(\n        self, model_name: str, use_gpu: bool\n    ) -&gt; Tuple[AutoModelForMaskedLM, AutoTokenizer]:\n        \"\"\"Prepares the model and tokenizer.\n\n        Args:\n            model_name: The name of the model to use.\n            use_gpu: Whether to use GPU/CUDA, if available.\n\n        Returns:\n            The huggingface model.\n            The huggingface tokenizer.\n            The device to use.\n\n        \"\"\"\n\n        # prepare the model\n        device = torch.device(\n            \"cuda\" if use_gpu and torch.cuda.is_available() else \"cpu\"\n        )\n        model = AutoModelForMaskedLM.from_pretrained(model_name).to(device)\n        # prepare the tokenizer\n        tokenizer = AutoTokenizer.from_pretrained(model_name)\n\n        return model, tokenizer, device\n\n    def _create_masks(self, entity: Entity) -&gt; List[dict]:\n        \"\"\"Creates the masks for the provided entity.\n\n        Args:\n            entity: The entity to create the masks for.\n\n        Returns:\n            The list of masks attributes, including the true text, mask text, start index, and end index within the original text.\n\n        \"\"\"\n\n        masks = []\n        chunks = re.split(r\"\\s+\", entity.text)\n        for idx in range(len(chunks)):\n            masks.append(\n                {\n                    \"true_text\": chunks[idx],\n                    \"mask_text\": \" \".join(\n                        chunks[0:idx] + [self.mask_token] + chunks[idx + 1 :]\n                    ),\n                    \"start_index\": entity.start_index,\n                    \"end_index\": entity.end_index,\n                }\n            )\n        return masks\n\n    def _get_context_text(self, text: str, start_index: int, end_index: int) -&gt; str:\n        \"\"\"Get the context text.\n\n        Args:\n            text: The text to get the context from.\n            start_index: The start index of the context window.\n            end_index: The end index of the context window.\n\n        Returns:\n            The context window text.\n\n        \"\"\"\n\n        min_index = max(0, start_index - self.context_window)\n        max_index = min(end_index + self.context_window, len(text))\n        return text[min_index:max_index]\n\n    def _prepare_generate_inputs(self, masks: List[dict], text: str) -&gt; List[str]:\n        \"\"\"Prepares the generate inputs.\n\n        Args:\n            masks: The list of masks attributes.\n            text: The text to prepare the generate inputs for.\n\n        Returns:\n            The list of generate inputs.\n\n        \"\"\"\n        return [\n            self._get_context_text(\n                text[: m[\"start_index\"]] + m[\"mask_text\"] + text[m[\"end_index\"] :],\n                m[\"start_index\"],\n                m[\"end_index\"],\n            )\n            for m in masks\n        ]\n\n    def _create_substitute(\n        self, entity: Entity, masks: List[dict], suggestions: List[dict]\n    ) -&gt; str:\n        \"\"\"Create a substitute for the entity.\n\n        Args:\n            entity: The entity to create the substitute for.\n            masks: The list of masks attributes.\n            suggestions: The list of substitute suggestions.\n\n        Returns:\n            The created and selected substitute text.\n\n        \"\"\"\n\n        substitute_chunks = []\n        for mask, suggestion in zip(masks, suggestions):\n            suggestion = suggestion if type(suggestion) == list else [suggestion]\n            viable_suggestions = list(\n                filter(\n                    lambda x: x[\"token_str\"] != mask[\"true_text\"]\n                    and re.match(entity.regex, x[\"token_str\"])\n                    and x[\"token_str\"] not in STOPWORDS,\n                    suggestion,\n                )\n            )\n            substitute_chunks.append([s[\"token_str\"] for s in viable_suggestions[:3]])\n        combinations = list(itertools.product(*substitute_chunks))\n        combinations = list(map(lambda x: \" \".join(set(x)), combinations))\n        return random.choice(combinations) if len(combinations) &gt; 0 else \"None\"\n</code></pre>"},{"location":"references/anonymize/generators/#anonipy.anonymize.generators.MaskLabelGenerator.__init__","title":"<code>__init__(*args, model_name='FacebookAI/xlm-roberta-large', use_gpu=False, context_window=100, **kwargs)</code>","text":"<p>Initializes the mask label generator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.generators import MaskLabelGenerator\n&gt;&gt;&gt; generator = MaskLabelGenerator(context_window=120, use_gpu=True)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>The name of the masking model to use.</p> <code>'FacebookAI/xlm-roberta-large'</code> <code>use_gpu</code> <code>bool</code> <p>Whether to use GPU/CUDA, if available.</p> <code>False</code> <code>context_window</code> <code>int</code> <p>The context window size.</p> <code>100</code> Source code in <code>anonipy/anonymize/generators/mask_label_generator.py</code> <pre><code>def __init__(\n    self,\n    *args,\n    model_name: str = \"FacebookAI/xlm-roberta-large\",\n    use_gpu: bool = False,\n    context_window: int = 100,\n    **kwargs,\n):\n    \"\"\"Initializes the mask label generator.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.generators import MaskLabelGenerator\n        &gt;&gt;&gt; generator = MaskLabelGenerator(context_window=120, use_gpu=True)\n\n    Args:\n        model_name: The name of the masking model to use.\n        use_gpu: Whether to use GPU/CUDA, if available.\n        context_window: The context window size.\n\n    \"\"\"\n\n    super().__init__(*args, **kwargs)\n    self.context_window = context_window\n    if use_gpu and not torch.cuda.is_available():\n        warnings.warn(\n            \"The use_gpu=True flag requires GPU/CUDA, but it is not available. Setting use_gpu=False.\"\n        )\n        use_gpu = False\n\n    # prepare the fill-mask pipeline and store the mask token\n    model, tokenizer, device = self._prepare_model_and_tokenizer(\n        model_name, use_gpu\n    )\n    self.mask_token = tokenizer.mask_token\n    self.pipeline = pipeline(\n        \"fill-mask\", model=model, tokenizer=tokenizer, top_k=40, device=device\n    )\n</code></pre>"},{"location":"references/anonymize/generators/#anonipy.anonymize.generators.MaskLabelGenerator.generate","title":"<code>generate(entity, text, *args, **kwargs)</code>","text":"<p>Generate the substitute for the entity using the masking model.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.generators import MaskLabelGenerator\n&gt;&gt;&gt; generator = MaskLabelGenerator(context_window=120, use_gpu=True)\n&gt;&gt;&gt; generator.generate(entity, text)\nlabel\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>Entity</code> <p>The entity used to generate the substitute.</p> required <code>text</code> <code>str</code> <p>The original text in which the entity is located; used to get the entity's context.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The generated substitute text.</p> Source code in <code>anonipy/anonymize/generators/mask_label_generator.py</code> <pre><code>def generate(self, entity: Entity, text: str, *args, **kwargs) -&gt; str:\n    \"\"\"Generate the substitute for the entity using the masking model.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.generators import MaskLabelGenerator\n        &gt;&gt;&gt; generator = MaskLabelGenerator(context_window=120, use_gpu=True)\n        &gt;&gt;&gt; generator.generate(entity, text)\n        label\n\n    Args:\n        entity: The entity used to generate the substitute.\n        text: The original text in which the entity is located; used to get the entity's context.\n\n    Returns:\n        The generated substitute text.\n\n    \"\"\"\n\n    masks = self._create_masks(entity)\n    input_texts = self._prepare_generate_inputs(masks, text)\n    suggestions = self.pipeline(input_texts)\n    return self._create_substitute(entity, masks, suggestions)\n</code></pre>"},{"location":"references/anonymize/generators/#anonipy.anonymize.generators.NumberGenerator","title":"<code>anonipy.anonymize.generators.NumberGenerator</code>","text":"<p>               Bases: <code>GeneratorInterface</code></p> <p>The class representing the number generator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.generators import NumberGenerator\n&gt;&gt;&gt; generator = NumberGenerator()\n&gt;&gt;&gt; generator.generate(entity)\n</code></pre> <p>Methods:</p> Name Description <code>generate</code> <p>Generates a substitute for the numeric entity.</p> Source code in <code>anonipy/anonymize/generators/number_generator.py</code> <pre><code>class NumberGenerator(GeneratorInterface):\n    \"\"\"The class representing the number generator.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.generators import NumberGenerator\n        &gt;&gt;&gt; generator = NumberGenerator()\n        &gt;&gt;&gt; generator.generate(entity)\n\n    Methods:\n        generate(self, entity):\n            Generates a substitute for the numeric entity.\n\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Initializes the number generator.\n\n        Examples:\n            &gt;&gt;&gt; from anonipy.anonymize.generators import NumberGenerator\n            &gt;&gt;&gt; generator = NumberGenerator()\n\n        \"\"\"\n\n        super().__init__(*args, **kwargs)\n\n    def generate(self, entity: Entity, *args, **kwargs) -&gt; str:\n        \"\"\"Generates the substitute for the numeric entity.\n\n        Examples:\n            &gt;&gt;&gt; from anonipy.anonymize.generators import NumberGenerator\n            &gt;&gt;&gt; generator = NumberGenerator()\n            &gt;&gt;&gt; generator.generate(entity)\n            \"1234567890\"\n\n        Args:\n            entity: The numeric entity to generate the numeric substitute.\n\n        Returns:\n            The generated numeric substitute.\n\n        Raises:\n            ValueError: If the entity type is not `integer`, `float`, `phone_number` or `custom`.\n\n        \"\"\"\n\n        if entity.type in [\"custom\"]:\n            warnings.warn(\n                \"The entity type is `custom`. Make sure the generator is returning appropriate values.\"\n            )\n        elif entity.type not in [\"integer\", \"float\", \"phone_number\"]:\n            raise ValueError(\n                \"The entity type must be `integer`, `float`, `phone_number` or `custom` to generate numbers.\"\n            )\n        return \"\".join(\n            [str(random.randint(0, 9)) if d.isdigit() else d for d in entity.text]\n        )\n</code></pre>"},{"location":"references/anonymize/generators/#anonipy.anonymize.generators.NumberGenerator.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initializes the number generator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.generators import NumberGenerator\n&gt;&gt;&gt; generator = NumberGenerator()\n</code></pre> Source code in <code>anonipy/anonymize/generators/number_generator.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"Initializes the number generator.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.generators import NumberGenerator\n        &gt;&gt;&gt; generator = NumberGenerator()\n\n    \"\"\"\n\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"references/anonymize/generators/#anonipy.anonymize.generators.NumberGenerator.generate","title":"<code>generate(entity, *args, **kwargs)</code>","text":"<p>Generates the substitute for the numeric entity.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.generators import NumberGenerator\n&gt;&gt;&gt; generator = NumberGenerator()\n&gt;&gt;&gt; generator.generate(entity)\n\"1234567890\"\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>Entity</code> <p>The numeric entity to generate the numeric substitute.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The generated numeric substitute.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the entity type is not <code>integer</code>, <code>float</code>, <code>phone_number</code> or <code>custom</code>.</p> Source code in <code>anonipy/anonymize/generators/number_generator.py</code> <pre><code>def generate(self, entity: Entity, *args, **kwargs) -&gt; str:\n    \"\"\"Generates the substitute for the numeric entity.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.generators import NumberGenerator\n        &gt;&gt;&gt; generator = NumberGenerator()\n        &gt;&gt;&gt; generator.generate(entity)\n        \"1234567890\"\n\n    Args:\n        entity: The numeric entity to generate the numeric substitute.\n\n    Returns:\n        The generated numeric substitute.\n\n    Raises:\n        ValueError: If the entity type is not `integer`, `float`, `phone_number` or `custom`.\n\n    \"\"\"\n\n    if entity.type in [\"custom\"]:\n        warnings.warn(\n            \"The entity type is `custom`. Make sure the generator is returning appropriate values.\"\n        )\n    elif entity.type not in [\"integer\", \"float\", \"phone_number\"]:\n        raise ValueError(\n            \"The entity type must be `integer`, `float`, `phone_number` or `custom` to generate numbers.\"\n        )\n    return \"\".join(\n        [str(random.randint(0, 9)) if d.isdigit() else d for d in entity.text]\n    )\n</code></pre>"},{"location":"references/anonymize/generators/#anonipy.anonymize.generators.DateGenerator","title":"<code>anonipy.anonymize.generators.DateGenerator</code>","text":"<p>               Bases: <code>GeneratorInterface</code></p> <p>The class representing the date generator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.generators import DateGenerator\n&gt;&gt;&gt; generator = DateGenerator(lang=\"de\")\n&gt;&gt;&gt; generator.generate(entity)\n</code></pre> <p>Attributes:</p> Name Type Description <code>lang</code> <code>(str, LANGUAGES)</code> <p>The language of the text.</p> <code>date_format</code> <code>str</code> <p>The date format in which the date should be generated.</p> <code>day_sigma</code> <code>int</code> <p>The range of the random date in days.</p> <p>Methods:</p> Name Description <code>generate</code> <p>Generate the date substitute based on the input parameters.</p> Source code in <code>anonipy/anonymize/generators/date_generator.py</code> <pre><code>class DateGenerator(GeneratorInterface):\n    \"\"\"The class representing the date generator.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.generators import DateGenerator\n        &gt;&gt;&gt; generator = DateGenerator(lang=\"de\")\n        &gt;&gt;&gt; generator.generate(entity)\n\n    Attributes:\n        lang (str, LANGUAGES): The language of the text.\n        date_format (str): The date format in which the date should be generated.\n        day_sigma (int): The range of the random date in days.\n\n    Methods:\n        generate(entity, output_gen):\n            Generate the date substitute based on the input parameters.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        *args,\n        lang: Union[str, LANGUAGES] = \"en\",\n        date_format: str = \"auto\",\n        day_sigma: int = 30,\n        **kwargs,\n    ):\n        \"\"\"Initializes the date generator.\n\n        Examples:\n            &gt;&gt;&gt; from anonipy.anonymize.generators import DateGenerator\n            &gt;&gt;&gt; generator = DateGenerator()\n\n        Args:\n            lang: The language of the text.\n            date_format: The date format in which the date should be generated. More on date formats [see here](https://www.contensis.com/help-and-docs/guides/querying-your-content/zenql-search/date-formats).\n            day_sigma: The range of the random date in days.\n\n        \"\"\"\n\n        super().__init__(*args, **kwargs)\n        self.date_format = date_format\n        self.day_sigma = day_sigma\n\n        if isinstance(lang, str) and lang in LANGUAGES.supported_languages():\n            self.lang = lang\n        elif isinstance(lang, LANGUAGES):\n            self.lang = lang[0]\n        else:\n            raise Exception(f\"Unknown lang value: {lang}\")\n\n    def generate(\n        self,\n        entity: Entity,\n        *args,\n        sub_variant: DATE_TRANSFORM_VARIANTS = DATE_TRANSFORM_VARIANTS.RANDOM,\n        **kwargs,\n    ) -&gt; str:\n        \"\"\"Generate the entity substitute based on the input parameters.\n\n        Args:\n            entity: The entity to generate the date substitute from.\n            sub_variant: The substitute function variant to use.\n\n        Returns:\n            The generated date substitute.\n\n        Raises:\n            ValueError: If the entity type is not `date` or `custom`.\n\n        \"\"\"\n\n        if entity.type in [\"custom\"]:\n            warnings.warn(\n                \"The entity type is `custom`. Make sure the generator is returning appropriate values.\"\n            )\n        elif entity.type not in [\"date\"]:\n            raise ValueError(\"The entity type must be `date` to generate dates.\")\n\n        if not DATE_TRANSFORM_VARIANTS.is_valid(sub_variant):\n            raise ValueError(\n                f\"The sub_variant must be one of {', '.join(DATE_TRANSFORM_VARIANTS.values())} to generate dates.\"\n            )\n\n        # detect the date format\n        if self.date_format == \"auto\":\n            entity_date, date_format = detect_datetime_format(entity.text, self.lang)\n        else:\n            entity_date = dateparser.parse(entity.text, languages=[self.lang])\n            date_format = self.date_format\n\n        # validate the input values\n        if entity_date is None:\n            raise ValueError(f\"Entity `{entity.text}` is not a valid date.\")\n        if date_format is None or isinstance(date_format, ValueError):\n            raise ValueError(f\"Entity `{entity.text}` is not a valid date.\")\n\n        # generate the date substitute\n        generate_date = DATE_VARIANTS_MAPPING[sub_variant](entity_date, self.day_sigma)\n        return format_datetime(generate_date, format=date_format, locale=self.lang)\n</code></pre>"},{"location":"references/anonymize/generators/#anonipy.anonymize.generators.DateGenerator.__init__","title":"<code>__init__(*args, lang='en', date_format='auto', day_sigma=30, **kwargs)</code>","text":"<p>Initializes the date generator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.generators import DateGenerator\n&gt;&gt;&gt; generator = DateGenerator()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>lang</code> <code>Union[str, LANGUAGES]</code> <p>The language of the text.</p> <code>'en'</code> <code>date_format</code> <code>str</code> <p>The date format in which the date should be generated. More on date formats see here.</p> <code>'auto'</code> <code>day_sigma</code> <code>int</code> <p>The range of the random date in days.</p> <code>30</code> Source code in <code>anonipy/anonymize/generators/date_generator.py</code> <pre><code>def __init__(\n    self,\n    *args,\n    lang: Union[str, LANGUAGES] = \"en\",\n    date_format: str = \"auto\",\n    day_sigma: int = 30,\n    **kwargs,\n):\n    \"\"\"Initializes the date generator.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.generators import DateGenerator\n        &gt;&gt;&gt; generator = DateGenerator()\n\n    Args:\n        lang: The language of the text.\n        date_format: The date format in which the date should be generated. More on date formats [see here](https://www.contensis.com/help-and-docs/guides/querying-your-content/zenql-search/date-formats).\n        day_sigma: The range of the random date in days.\n\n    \"\"\"\n\n    super().__init__(*args, **kwargs)\n    self.date_format = date_format\n    self.day_sigma = day_sigma\n\n    if isinstance(lang, str) and lang in LANGUAGES.supported_languages():\n        self.lang = lang\n    elif isinstance(lang, LANGUAGES):\n        self.lang = lang[0]\n    else:\n        raise Exception(f\"Unknown lang value: {lang}\")\n</code></pre>"},{"location":"references/anonymize/generators/#anonipy.anonymize.generators.DateGenerator.generate","title":"<code>generate(entity, *args, sub_variant=DATE_TRANSFORM_VARIANTS.RANDOM, **kwargs)</code>","text":"<p>Generate the entity substitute based on the input parameters.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>Entity</code> <p>The entity to generate the date substitute from.</p> required <code>sub_variant</code> <code>DATE_TRANSFORM_VARIANTS</code> <p>The substitute function variant to use.</p> <code>RANDOM</code> <p>Returns:</p> Type Description <code>str</code> <p>The generated date substitute.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the entity type is not <code>date</code> or <code>custom</code>.</p> Source code in <code>anonipy/anonymize/generators/date_generator.py</code> <pre><code>def generate(\n    self,\n    entity: Entity,\n    *args,\n    sub_variant: DATE_TRANSFORM_VARIANTS = DATE_TRANSFORM_VARIANTS.RANDOM,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Generate the entity substitute based on the input parameters.\n\n    Args:\n        entity: The entity to generate the date substitute from.\n        sub_variant: The substitute function variant to use.\n\n    Returns:\n        The generated date substitute.\n\n    Raises:\n        ValueError: If the entity type is not `date` or `custom`.\n\n    \"\"\"\n\n    if entity.type in [\"custom\"]:\n        warnings.warn(\n            \"The entity type is `custom`. Make sure the generator is returning appropriate values.\"\n        )\n    elif entity.type not in [\"date\"]:\n        raise ValueError(\"The entity type must be `date` to generate dates.\")\n\n    if not DATE_TRANSFORM_VARIANTS.is_valid(sub_variant):\n        raise ValueError(\n            f\"The sub_variant must be one of {', '.join(DATE_TRANSFORM_VARIANTS.values())} to generate dates.\"\n        )\n\n    # detect the date format\n    if self.date_format == \"auto\":\n        entity_date, date_format = detect_datetime_format(entity.text, self.lang)\n    else:\n        entity_date = dateparser.parse(entity.text, languages=[self.lang])\n        date_format = self.date_format\n\n    # validate the input values\n    if entity_date is None:\n        raise ValueError(f\"Entity `{entity.text}` is not a valid date.\")\n    if date_format is None or isinstance(date_format, ValueError):\n        raise ValueError(f\"Entity `{entity.text}` is not a valid date.\")\n\n    # generate the date substitute\n    generate_date = DATE_VARIANTS_MAPPING[sub_variant](entity_date, self.day_sigma)\n    return format_datetime(generate_date, format=date_format, locale=self.lang)\n</code></pre>"},{"location":"references/anonymize/generators/#anonipy.anonymize.generators.GeneratorInterface","title":"<code>anonipy.anonymize.generators.GeneratorInterface</code>","text":"<p>The class representing the generator interface.</p> <p>All generators should inherit from this class.</p> <p>Methods:</p> Name Description <code>generate</code> <p>Generate a substitute for the entity.</p> Source code in <code>anonipy/anonymize/generators/interface.py</code> <pre><code>class GeneratorInterface:\n    \"\"\"The class representing the generator interface.\n\n    All generators should inherit from this class.\n\n    Methods:\n        generate(entity):\n            Generate a substitute for the entity.\n\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        pass\n\n    def generate(self, entity: Entity, *args, **kwargs):\n        pass\n</code></pre>"},{"location":"references/anonymize/pipeline/","title":"Pipeline Module","text":""},{"location":"references/anonymize/pipeline/#anonipy.anonymize.pipeline","title":"<code>anonipy.anonymize.pipeline</code>","text":"<p>Module containing the <code>pipeline</code>.</p> <p>The <code>pipeline</code> module provides a class for anonymizing files using a pipeline of extractors and strategies.</p> <p>Classes:</p> Name Description <code>Pipeline</code> <p>The class representing the anonymization pipeline.</p>"},{"location":"references/anonymize/pipeline/#anonipy.anonymize.pipeline.Pipeline","title":"<code>anonipy.anonymize.pipeline.Pipeline</code>","text":"<p>A class for anonymizing files using a pipeline of extractors and strategies.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.pipeline import Pipeline\n&gt;&gt;&gt; extractor = NERExtractor(labels, lang=LANGUAGES.ENGLISH)\n&gt;&gt;&gt; strategy = RedactionStrategy()\n&gt;&gt;&gt; pipeline = Pipeline(extractor, strategy)\n&gt;&gt;&gt; pipeline.anonymize(\"/path/to/input_dir\", \"/path/to/output_dir\", flatten=True)\n</code></pre> <p>Attributes:</p> Name Type Description <code>extractor</code> <code>(ExtractorInterface, MultiExtractor, List[ExtractorInterface])</code> <p>The extractor to use for entity extraction.</p> <code>strategy</code> <code>StrategyInterface</code> <p>The strategy to use for anonymization.</p> <p>Methods:</p> Name Description <code>anonymize</code> <p>Anonymize files in the input directory and save the anonymized files to the output directory.</p> Source code in <code>anonipy/anonymize/pipeline.py</code> <pre><code>class Pipeline:\n    \"\"\"A class for anonymizing files using a pipeline of extractors and strategies.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.pipeline import Pipeline\n        &gt;&gt;&gt; extractor = NERExtractor(labels, lang=LANGUAGES.ENGLISH)\n        &gt;&gt;&gt; strategy = RedactionStrategy()\n        &gt;&gt;&gt; pipeline = Pipeline(extractor, strategy)\n        &gt;&gt;&gt; pipeline.anonymize(\"/path/to/input_dir\", \"/path/to/output_dir\", flatten=True)\n\n    Attributes:\n        extractor (ExtractorInterface, MultiExtractor, List[ExtractorInterface]): The extractor to use for entity extraction.\n        strategy (StrategyInterface): The strategy to use for anonymization.\n\n    Methods:\n        anonymize(input_dir, output_dir, flatten=False):\n            Anonymize files in the input directory and save the anonymized files to the output directory.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        extractor: Union[ExtractorInterface, MultiExtractor, List[ExtractorInterface]],\n        strategy: StrategyInterface,\n    ):\n        \"\"\"Initialize the pipeline.\n\n        Examples:\n            &gt;&gt;&gt; from anonipy.anonymize.pipeline import Pipeline\n            &gt;&gt;&gt; extractor = NERExtractor(labels, lang=LANGUAGES.ENGLISH)\n            &gt;&gt;&gt; strategy = RedactionStrategy()\n            &gt;&gt;&gt; pipeline = Pipeline(extractor, strategy)\n\n        Args:\n            extractor: The extractor to use for entity extraction.\n            strategy: The strategy to use for anonymization.\n\n        \"\"\"\n\n        if isinstance(extractor, ExtractorInterface) or isinstance(\n            extractor, MultiExtractor\n        ):\n            self.extractor = extractor\n        elif isinstance(extractor, list):\n            self.extractor = MultiExtractor(extractor)\n        else:\n            raise ValueError(\n                \"Extractor must be an ExtractorInterface or a list of ExtractorInterface.\"\n            )\n\n        if not isinstance(strategy, StrategyInterface):\n            raise ValueError(\"Strategy must be a StrategyInterface.\")\n\n        self.strategy = strategy\n\n    def anonymize(self, input_dir: str, output_dir: str, flatten: bool = False) -&gt; dict:\n        \"\"\"Anonymize files in the input directory and save the anonymized files to the output directory.\n\n        Args:\n            input_dir: The path to the input directory containing files to be anonymized.\n            output_dir: The path to the output directory where anonymized files will be saved.\n            flatten: Whether to flatten the output directory structure. Defaults to False.\n\n        Raises:\n            ValueError: If the input directory does not exist or if the input and output directories are the same.\n\n        Returns:\n            A dictionary mapping the original file paths to the anonymized file paths.\n\n        \"\"\"\n\n        if not os.path.exists(input_dir):\n            raise ValueError(f\"Input directory '{input_dir}' does not exist.\")\n\n        if os.path.abspath(input_dir) == os.path.abspath(output_dir):\n            raise ValueError(\"Input and output directories cannot be the same.\")\n\n        if not os.path.exists(output_dir):\n            os.makedirs(output_dir, exist_ok=True)\n\n        anonymized_files_count = 1\n        file_name_mapping = {}\n\n        for root, _, files in os.walk(input_dir):\n            for file_name in files:\n                file_path = os.path.join(root, file_name)\n\n                try:\n                    anonymized_text = self._anonymize_file(file_path)\n                    if anonymized_text is None:\n                        continue\n                except Exception as e:\n                    warnings.warn(f\"Problems while processing file {file_path}: {e}\")\n                    continue\n\n                _, ext = os.path.splitext(file_name)\n                output_file_name = f\"file{anonymized_files_count}_anony{ext}\"\n                anonymized_files_count += 1\n\n                relative_path = os.path.relpath(file_path, input_dir)\n\n                if flatten:\n                    output_file_path = os.path.join(output_dir, output_file_name)\n                else:\n                    output_file_path = os.path.join(\n                        output_dir, os.path.dirname(relative_path), output_file_name\n                    )\n                    os.makedirs(os.path.dirname(output_file_path), exist_ok=True)\n\n                write_file(anonymized_text, output_file_path)\n\n                file_path_before = os.path.join(\n                    input_dir.split(os.sep)[-1], relative_path\n                )\n                file_path_after = os.path.relpath(output_file_path, output_dir)\n                file_name_mapping[file_path_before] = os.path.join(\n                    output_dir.split(os.sep)[-1], file_path_after\n                )\n\n        return file_name_mapping\n\n    def _anonymize_file(self, file_path: str) -&gt; Union[str, None]:\n        \"\"\"Anonymize a single file.\n\n        Args:\n            file_path: The path to the file to be anonymized.\n\n        Returns:\n            The anonymized text or None if the file is empty or if entity extraction fails.\n\n        \"\"\"\n\n        original_text = open_file(file_path)\n        if original_text is None or not original_text.strip():\n            warnings.warn(\n                f\"Skipping file {file_path}: Failed to read or file is empty.\"\n            )\n            return None\n\n        _, entities = self.extractor(original_text)\n\n        if not entities:\n            warnings.warn(\n                f\"Skipping file {file_path}: Entity extraction returned None.\"\n            )\n            return None\n\n        anonymized_text, _ = self.strategy.anonymize(original_text, entities)\n\n        return anonymized_text\n</code></pre>"},{"location":"references/anonymize/pipeline/#anonipy.anonymize.pipeline.Pipeline.__init__","title":"<code>__init__(extractor, strategy)</code>","text":"<p>Initialize the pipeline.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.pipeline import Pipeline\n&gt;&gt;&gt; extractor = NERExtractor(labels, lang=LANGUAGES.ENGLISH)\n&gt;&gt;&gt; strategy = RedactionStrategy()\n&gt;&gt;&gt; pipeline = Pipeline(extractor, strategy)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>extractor</code> <code>Union[ExtractorInterface, MultiExtractor, List[ExtractorInterface]]</code> <p>The extractor to use for entity extraction.</p> required <code>strategy</code> <code>StrategyInterface</code> <p>The strategy to use for anonymization.</p> required Source code in <code>anonipy/anonymize/pipeline.py</code> <pre><code>def __init__(\n    self,\n    extractor: Union[ExtractorInterface, MultiExtractor, List[ExtractorInterface]],\n    strategy: StrategyInterface,\n):\n    \"\"\"Initialize the pipeline.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.pipeline import Pipeline\n        &gt;&gt;&gt; extractor = NERExtractor(labels, lang=LANGUAGES.ENGLISH)\n        &gt;&gt;&gt; strategy = RedactionStrategy()\n        &gt;&gt;&gt; pipeline = Pipeline(extractor, strategy)\n\n    Args:\n        extractor: The extractor to use for entity extraction.\n        strategy: The strategy to use for anonymization.\n\n    \"\"\"\n\n    if isinstance(extractor, ExtractorInterface) or isinstance(\n        extractor, MultiExtractor\n    ):\n        self.extractor = extractor\n    elif isinstance(extractor, list):\n        self.extractor = MultiExtractor(extractor)\n    else:\n        raise ValueError(\n            \"Extractor must be an ExtractorInterface or a list of ExtractorInterface.\"\n        )\n\n    if not isinstance(strategy, StrategyInterface):\n        raise ValueError(\"Strategy must be a StrategyInterface.\")\n\n    self.strategy = strategy\n</code></pre>"},{"location":"references/anonymize/pipeline/#anonipy.anonymize.pipeline.Pipeline.anonymize","title":"<code>anonymize(input_dir, output_dir, flatten=False)</code>","text":"<p>Anonymize files in the input directory and save the anonymized files to the output directory.</p> <p>Parameters:</p> Name Type Description Default <code>input_dir</code> <code>str</code> <p>The path to the input directory containing files to be anonymized.</p> required <code>output_dir</code> <code>str</code> <p>The path to the output directory where anonymized files will be saved.</p> required <code>flatten</code> <code>bool</code> <p>Whether to flatten the output directory structure. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input directory does not exist or if the input and output directories are the same.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary mapping the original file paths to the anonymized file paths.</p> Source code in <code>anonipy/anonymize/pipeline.py</code> <pre><code>def anonymize(self, input_dir: str, output_dir: str, flatten: bool = False) -&gt; dict:\n    \"\"\"Anonymize files in the input directory and save the anonymized files to the output directory.\n\n    Args:\n        input_dir: The path to the input directory containing files to be anonymized.\n        output_dir: The path to the output directory where anonymized files will be saved.\n        flatten: Whether to flatten the output directory structure. Defaults to False.\n\n    Raises:\n        ValueError: If the input directory does not exist or if the input and output directories are the same.\n\n    Returns:\n        A dictionary mapping the original file paths to the anonymized file paths.\n\n    \"\"\"\n\n    if not os.path.exists(input_dir):\n        raise ValueError(f\"Input directory '{input_dir}' does not exist.\")\n\n    if os.path.abspath(input_dir) == os.path.abspath(output_dir):\n        raise ValueError(\"Input and output directories cannot be the same.\")\n\n    if not os.path.exists(output_dir):\n        os.makedirs(output_dir, exist_ok=True)\n\n    anonymized_files_count = 1\n    file_name_mapping = {}\n\n    for root, _, files in os.walk(input_dir):\n        for file_name in files:\n            file_path = os.path.join(root, file_name)\n\n            try:\n                anonymized_text = self._anonymize_file(file_path)\n                if anonymized_text is None:\n                    continue\n            except Exception as e:\n                warnings.warn(f\"Problems while processing file {file_path}: {e}\")\n                continue\n\n            _, ext = os.path.splitext(file_name)\n            output_file_name = f\"file{anonymized_files_count}_anony{ext}\"\n            anonymized_files_count += 1\n\n            relative_path = os.path.relpath(file_path, input_dir)\n\n            if flatten:\n                output_file_path = os.path.join(output_dir, output_file_name)\n            else:\n                output_file_path = os.path.join(\n                    output_dir, os.path.dirname(relative_path), output_file_name\n                )\n                os.makedirs(os.path.dirname(output_file_path), exist_ok=True)\n\n            write_file(anonymized_text, output_file_path)\n\n            file_path_before = os.path.join(\n                input_dir.split(os.sep)[-1], relative_path\n            )\n            file_path_after = os.path.relpath(output_file_path, output_dir)\n            file_name_mapping[file_path_before] = os.path.join(\n                output_dir.split(os.sep)[-1], file_path_after\n            )\n\n    return file_name_mapping\n</code></pre>"},{"location":"references/anonymize/strategies/","title":"Strategies Module","text":""},{"location":"references/anonymize/strategies/#anonipy.anonymize.strategies","title":"<code>anonipy.anonymize.strategies</code>","text":"<p>Module containing the <code>strategies</code>.</p> <p>The <code>strategies</code> module provides a set of strategies used to anonymize the identified vulnerable data.</p> <p>Classes:</p> Name Description <code>RedactionStrategy</code> <p>The class representing the redaction strategy.</p> <code>MaskingStrategy</code> <p>The class representing the masking strategy.</p> <code>PseudonymizationStrategy</code> <p>The class representing the pseudonymization strategy.</p>"},{"location":"references/anonymize/strategies/#anonipy.anonymize.strategies.RedactionStrategy","title":"<code>anonipy.anonymize.strategies.RedactionStrategy</code>","text":"<p>               Bases: <code>StrategyInterface</code></p> <p>The class representing the redaction strategy.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.strategies import RedactionStrategy\n&gt;&gt;&gt; strategy = RedactionStrategy()\n&gt;&gt;&gt; strategy.anonymize(text, entities)\n</code></pre> <p>Attributes:</p> Name Type Description <code>substitute_label</code> <code>str</code> <p>The label to substitute in the anonymized text.</p> <p>Methods:</p> Name Description <code>anonymize</code> <p>Anonymize the text based on the entities.</p> Source code in <code>anonipy/anonymize/strategies/redaction.py</code> <pre><code>class RedactionStrategy(StrategyInterface):\n    \"\"\"The class representing the redaction strategy.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.strategies import RedactionStrategy\n        &gt;&gt;&gt; strategy = RedactionStrategy()\n        &gt;&gt;&gt; strategy.anonymize(text, entities)\n\n    Attributes:\n        substitute_label (str): The label to substitute in the anonymized text.\n\n    Methods:\n        anonymize(text, entities):\n            Anonymize the text based on the entities.\n\n    \"\"\"\n\n    def __init__(self, substitute_label: str = \"[REDACTED]\", *args, **kwargs) -&gt; None:\n        \"\"\"Initializes the redaction strategy.\n\n        Examples:\n            &gt;&gt;&gt; from anonipy.anonymize.strategies import RedactionStrategy\n            &gt;&gt;&gt; strategy = RedactionStrategy()\n\n        Args:\n            substitute_label: The label to substitute in the anonymized text.\n\n        \"\"\"\n\n        super().__init__(*args, **kwargs)\n        self.substitute_label = substitute_label or \"[REDACTED]\"\n\n    def anonymize(\n        self, text: str, entities: List[Entity], *args, **kwargs\n    ) -&gt; Tuple[str, List[Replacement]]:\n        \"\"\"Anonymize the text using the redaction strategy.\n\n        Examples:\n            &gt;&gt;&gt; from anonipy.anonymize.strategies import RedactionStrategy\n            &gt;&gt;&gt; strategy = RedactionStrategy()\n            &gt;&gt;&gt; strategy.anonymize(text, entities)\n\n        Args:\n            text: The text to anonymize.\n            entities: The list of entities to anonymize.\n\n        Returns:\n            The anonymized text.\n            The list of applied replacements.\n\n        \"\"\"\n\n        replacements = [self._create_replacement(ent) for ent in entities]\n        anonymized_text, replacements = anonymize(text, replacements)\n        return anonymized_text, replacements\n\n    # ===========================================\n    # Private methods\n    # ===========================================\n\n    def _create_replacement(self, entity: Entity) -&gt; Replacement:\n        \"\"\"Creates a replacement for the entity.\n\n        Args:\n            entity: The entity to create the replacement for.\n\n        Returns:\n            The created replacement.\n\n        \"\"\"\n\n        return {\n            \"original_text\": entity.text,\n            \"label\": entity.label,\n            \"start_index\": entity.start_index,\n            \"end_index\": entity.end_index,\n            \"anonymized_text\": self.substitute_label,\n        }\n</code></pre>"},{"location":"references/anonymize/strategies/#anonipy.anonymize.strategies.RedactionStrategy.__init__","title":"<code>__init__(substitute_label='[REDACTED]', *args, **kwargs)</code>","text":"<p>Initializes the redaction strategy.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.strategies import RedactionStrategy\n&gt;&gt;&gt; strategy = RedactionStrategy()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>substitute_label</code> <code>str</code> <p>The label to substitute in the anonymized text.</p> <code>'[REDACTED]'</code> Source code in <code>anonipy/anonymize/strategies/redaction.py</code> <pre><code>def __init__(self, substitute_label: str = \"[REDACTED]\", *args, **kwargs) -&gt; None:\n    \"\"\"Initializes the redaction strategy.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.strategies import RedactionStrategy\n        &gt;&gt;&gt; strategy = RedactionStrategy()\n\n    Args:\n        substitute_label: The label to substitute in the anonymized text.\n\n    \"\"\"\n\n    super().__init__(*args, **kwargs)\n    self.substitute_label = substitute_label or \"[REDACTED]\"\n</code></pre>"},{"location":"references/anonymize/strategies/#anonipy.anonymize.strategies.RedactionStrategy.anonymize","title":"<code>anonymize(text, entities, *args, **kwargs)</code>","text":"<p>Anonymize the text using the redaction strategy.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.strategies import RedactionStrategy\n&gt;&gt;&gt; strategy = RedactionStrategy()\n&gt;&gt;&gt; strategy.anonymize(text, entities)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to anonymize.</p> required <code>entities</code> <code>List[Entity]</code> <p>The list of entities to anonymize.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The anonymized text.</p> <code>List[Replacement]</code> <p>The list of applied replacements.</p> Source code in <code>anonipy/anonymize/strategies/redaction.py</code> <pre><code>def anonymize(\n    self, text: str, entities: List[Entity], *args, **kwargs\n) -&gt; Tuple[str, List[Replacement]]:\n    \"\"\"Anonymize the text using the redaction strategy.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.strategies import RedactionStrategy\n        &gt;&gt;&gt; strategy = RedactionStrategy()\n        &gt;&gt;&gt; strategy.anonymize(text, entities)\n\n    Args:\n        text: The text to anonymize.\n        entities: The list of entities to anonymize.\n\n    Returns:\n        The anonymized text.\n        The list of applied replacements.\n\n    \"\"\"\n\n    replacements = [self._create_replacement(ent) for ent in entities]\n    anonymized_text, replacements = anonymize(text, replacements)\n    return anonymized_text, replacements\n</code></pre>"},{"location":"references/anonymize/strategies/#anonipy.anonymize.strategies.MaskingStrategy","title":"<code>anonipy.anonymize.strategies.MaskingStrategy</code>","text":"<p>               Bases: <code>StrategyInterface</code></p> <p>The class representing the masking strategy.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.strategies import MaskingStrategy\n&gt;&gt;&gt; strategy = MaskingStrategy()\n&gt;&gt;&gt; strategy.anonymize(text, entities)\n</code></pre> <p>Attributes:</p> Name Type Description <code>substitute_label</code> <code>str</code> <p>The label to substitute in the anonymized text.</p> <p>Methods:</p> Name Description <code>anonymize</code> <p>Anonymize the text based on the entities.</p> Source code in <code>anonipy/anonymize/strategies/masking.py</code> <pre><code>class MaskingStrategy(StrategyInterface):\n    \"\"\"The class representing the masking strategy.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.strategies import MaskingStrategy\n        &gt;&gt;&gt; strategy = MaskingStrategy()\n        &gt;&gt;&gt; strategy.anonymize(text, entities)\n\n    Attributes:\n        substitute_label (str): The label to substitute in the anonymized text.\n\n    Methods:\n        anonymize(text, entities):\n            Anonymize the text based on the entities.\n\n    \"\"\"\n\n    def __init__(self, substitute_label: str = \"*\", *args, **kwargs):\n        \"\"\"Initializes the masking strategy.\n\n        Examples:\n            &gt;&gt;&gt; from anonipy.anonymize.strategies import MaskingStrategy\n            &gt;&gt;&gt; strategy = MaskingStrategy()\n\n        Args:\n            substitute_label: The label to substitute in the anonymized text.\n\n        \"\"\"\n\n        super().__init__(*args, **kwargs)\n        self.substitute_label = substitute_label or \"*\"\n\n    def anonymize(\n        self, text: str, entities: List[Entity], *args, **kwargs\n    ) -&gt; Tuple[str, List[Replacement]]:\n        \"\"\"Anonymize the text using the masking strategy.\n\n        Examples:\n            &gt;&gt;&gt; from anonipy.anonymize.strategies import MaskingStrategy\n            &gt;&gt;&gt; strategy = MaskingStrategy()\n            &gt;&gt;&gt; strategy.anonymize(text, entities)\n\n        Args:\n            text: The text to anonymize.\n            entities: The list of entities to anonymize.\n\n        Returns:\n            The anonymized text.\n            The list of applied replacements.\n\n        \"\"\"\n\n        replacements = [self._create_replacement(ent) for ent in entities]\n        anonymized_text, replacements = anonymize(text, replacements)\n        return anonymized_text, replacements\n\n    # ===========================================\n    # Private methods\n    # ===========================================\n\n    def _create_replacement(self, entity: Entity) -&gt; Replacement:\n        \"\"\"Creates a replacement for the entity.\n\n        Args:\n            entity: The entity to create the replacement for.\n\n        Returns:\n            The created replacement.\n\n        \"\"\"\n\n        mask = self._create_mask(entity)\n        return {\n            \"original_text\": entity.text,\n            \"label\": entity.label,\n            \"start_index\": entity.start_index,\n            \"end_index\": entity.end_index,\n            \"anonymized_text\": mask,\n        }\n\n    def _create_mask(self, entity: Entity) -&gt; str:\n        \"\"\"Creates a mask for the entity.\n\n        Args:\n            entity: The entity to create the mask for.\n\n        Returns:\n            The created mask.\n\n        \"\"\"\n\n        # TODO: add random length substitution\n        return \" \".join(\n            [\n                self.substitute_label * len(chunk)\n                for chunk in re.split(r\"\\s+\", entity.text)\n            ]\n        )\n</code></pre>"},{"location":"references/anonymize/strategies/#anonipy.anonymize.strategies.MaskingStrategy.__init__","title":"<code>__init__(substitute_label='*', *args, **kwargs)</code>","text":"<p>Initializes the masking strategy.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.strategies import MaskingStrategy\n&gt;&gt;&gt; strategy = MaskingStrategy()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>substitute_label</code> <code>str</code> <p>The label to substitute in the anonymized text.</p> <code>'*'</code> Source code in <code>anonipy/anonymize/strategies/masking.py</code> <pre><code>def __init__(self, substitute_label: str = \"*\", *args, **kwargs):\n    \"\"\"Initializes the masking strategy.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.strategies import MaskingStrategy\n        &gt;&gt;&gt; strategy = MaskingStrategy()\n\n    Args:\n        substitute_label: The label to substitute in the anonymized text.\n\n    \"\"\"\n\n    super().__init__(*args, **kwargs)\n    self.substitute_label = substitute_label or \"*\"\n</code></pre>"},{"location":"references/anonymize/strategies/#anonipy.anonymize.strategies.MaskingStrategy.anonymize","title":"<code>anonymize(text, entities, *args, **kwargs)</code>","text":"<p>Anonymize the text using the masking strategy.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.strategies import MaskingStrategy\n&gt;&gt;&gt; strategy = MaskingStrategy()\n&gt;&gt;&gt; strategy.anonymize(text, entities)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to anonymize.</p> required <code>entities</code> <code>List[Entity]</code> <p>The list of entities to anonymize.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The anonymized text.</p> <code>List[Replacement]</code> <p>The list of applied replacements.</p> Source code in <code>anonipy/anonymize/strategies/masking.py</code> <pre><code>def anonymize(\n    self, text: str, entities: List[Entity], *args, **kwargs\n) -&gt; Tuple[str, List[Replacement]]:\n    \"\"\"Anonymize the text using the masking strategy.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.strategies import MaskingStrategy\n        &gt;&gt;&gt; strategy = MaskingStrategy()\n        &gt;&gt;&gt; strategy.anonymize(text, entities)\n\n    Args:\n        text: The text to anonymize.\n        entities: The list of entities to anonymize.\n\n    Returns:\n        The anonymized text.\n        The list of applied replacements.\n\n    \"\"\"\n\n    replacements = [self._create_replacement(ent) for ent in entities]\n    anonymized_text, replacements = anonymize(text, replacements)\n    return anonymized_text, replacements\n</code></pre>"},{"location":"references/anonymize/strategies/#anonipy.anonymize.strategies.PseudonymizationStrategy","title":"<code>anonipy.anonymize.strategies.PseudonymizationStrategy</code>","text":"<p>               Bases: <code>StrategyInterface</code></p> <p>The class representing the pseudonymization strategy.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.strategies import PseudonymizationStrategy\n&gt;&gt;&gt; strategy = PseudonymizationStrategy(mapping)\n&gt;&gt;&gt; strategy.anonymize(text, entities)\n</code></pre> <p>Attributes:</p> Name Type Description <code>mapping</code> <p>The mapping of entities to pseudonyms.</p> <p>Methods:</p> Name Description <code>anonymize</code> <p>Anonymize the text based on the entities.</p> Source code in <code>anonipy/anonymize/strategies/pseudonymization.py</code> <pre><code>class PseudonymizationStrategy(StrategyInterface):\n    \"\"\"The class representing the pseudonymization strategy.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.strategies import PseudonymizationStrategy\n        &gt;&gt;&gt; strategy = PseudonymizationStrategy(mapping)\n        &gt;&gt;&gt; strategy.anonymize(text, entities)\n\n    Attributes:\n        mapping: The mapping of entities to pseudonyms.\n\n    Methods:\n        anonymize(text, entities):\n            Anonymize the text based on the entities.\n\n    \"\"\"\n\n    def __init__(self, mapping: Callable, *args, **kwargs):\n        \"\"\"Initializes the pseudonymization strategy.\n\n        Examples:\n            &gt;&gt;&gt; from anonipy.anonymize.strategies import PseudonymizationStrategy\n            &gt;&gt;&gt; strategy = PseudonymizationStrategy(mapping)\n\n        Args:\n            mapping: The mapping function on how to handle each entity type.\n\n        \"\"\"\n\n        super().__init__(*args, **kwargs)\n        self.mapping = mapping\n\n    def anonymize(\n        self, text: str, entities: List[Entity], *args, **kwargs\n    ) -&gt; Tuple[str, List[Replacement]]:\n        \"\"\"Anonymize the text using the pseudonymization strategy.\n\n        Examples:\n            &gt;&gt;&gt; from anonipy.anonymize.strategies import PseudonymizationStrategy\n            &gt;&gt;&gt; strategy = PseudonymizationStrategy(mapping)\n            &gt;&gt;&gt; strategy.anonymize(text, entities)\n\n        Args:\n            text: The text to anonymize.\n            entities: The list of entities to anonymize.\n\n        Returns:\n            The anonymized text.\n            The list of applied replacements.\n\n        \"\"\"\n\n        replacements = []\n        for ent in entities:\n            replacement = self._create_replacement(ent, text, replacements)\n            replacements.append(replacement)\n        anonymized_text, replacements = anonymize(text, replacements)\n        return anonymized_text, replacements\n\n    # ===========================================\n    # Private methods\n    # ===========================================\n\n    def _create_replacement(\n        self, entity: Entity, text: str, replacements: List[dict]\n    ) -&gt; Replacement:\n        \"\"\"Creates a replacement for the entity.\n\n        Args:\n            entity: The entity to create the replacement for.\n            text: The text to anonymize.\n            replacements: The list of existing replacements.\n\n        Returns:\n            The created replacement.\n\n        \"\"\"\n\n        # check if the replacement already exists\n        anonymized_text = self._check_replacement(entity, replacements)\n        # create a new replacement if it doesn't exist\n        anonymized_text = (\n            self.mapping(text, entity) if not anonymized_text else anonymized_text\n        )\n        return {\n            \"original_text\": entity.text,\n            \"label\": entity.label,\n            \"start_index\": entity.start_index,\n            \"end_index\": entity.end_index,\n            \"anonymized_text\": anonymized_text,\n        }\n\n    def _check_replacement(\n        self, entity: Entity, replacements: List[Replacement]\n    ) -&gt; str:\n        \"\"\"Checks if a suitable replacement already exists.\n\n        Args:\n            entity: The entity to check.\n            replacements: The list of replacements.\n\n        Returns:\n            The anonymized text if the replacement already exists, None otherwise.\n\n        \"\"\"\n        existing_replacement = list(\n            filter(lambda x: x[\"original_text\"] == entity.text, replacements)\n        )\n        return (\n            existing_replacement[0][\"anonymized_text\"]\n            if len(existing_replacement) &gt; 0\n            else None\n        )\n</code></pre>"},{"location":"references/anonymize/strategies/#anonipy.anonymize.strategies.PseudonymizationStrategy.__init__","title":"<code>__init__(mapping, *args, **kwargs)</code>","text":"<p>Initializes the pseudonymization strategy.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.strategies import PseudonymizationStrategy\n&gt;&gt;&gt; strategy = PseudonymizationStrategy(mapping)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Callable</code> <p>The mapping function on how to handle each entity type.</p> required Source code in <code>anonipy/anonymize/strategies/pseudonymization.py</code> <pre><code>def __init__(self, mapping: Callable, *args, **kwargs):\n    \"\"\"Initializes the pseudonymization strategy.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.strategies import PseudonymizationStrategy\n        &gt;&gt;&gt; strategy = PseudonymizationStrategy(mapping)\n\n    Args:\n        mapping: The mapping function on how to handle each entity type.\n\n    \"\"\"\n\n    super().__init__(*args, **kwargs)\n    self.mapping = mapping\n</code></pre>"},{"location":"references/anonymize/strategies/#anonipy.anonymize.strategies.PseudonymizationStrategy.anonymize","title":"<code>anonymize(text, entities, *args, **kwargs)</code>","text":"<p>Anonymize the text using the pseudonymization strategy.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.strategies import PseudonymizationStrategy\n&gt;&gt;&gt; strategy = PseudonymizationStrategy(mapping)\n&gt;&gt;&gt; strategy.anonymize(text, entities)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to anonymize.</p> required <code>entities</code> <code>List[Entity]</code> <p>The list of entities to anonymize.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The anonymized text.</p> <code>List[Replacement]</code> <p>The list of applied replacements.</p> Source code in <code>anonipy/anonymize/strategies/pseudonymization.py</code> <pre><code>def anonymize(\n    self, text: str, entities: List[Entity], *args, **kwargs\n) -&gt; Tuple[str, List[Replacement]]:\n    \"\"\"Anonymize the text using the pseudonymization strategy.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.strategies import PseudonymizationStrategy\n        &gt;&gt;&gt; strategy = PseudonymizationStrategy(mapping)\n        &gt;&gt;&gt; strategy.anonymize(text, entities)\n\n    Args:\n        text: The text to anonymize.\n        entities: The list of entities to anonymize.\n\n    Returns:\n        The anonymized text.\n        The list of applied replacements.\n\n    \"\"\"\n\n    replacements = []\n    for ent in entities:\n        replacement = self._create_replacement(ent, text, replacements)\n        replacements.append(replacement)\n    anonymized_text, replacements = anonymize(text, replacements)\n    return anonymized_text, replacements\n</code></pre>"},{"location":"references/anonymize/strategies/#anonipy.anonymize.strategies.StrategyInterface","title":"<code>anonipy.anonymize.strategies.StrategyInterface</code>","text":"<p>The class representing the strategy interface.</p> <p>All strategies should inherit from this class.</p> <p>Methods:</p> Name Description <code>anonymize</code> <p>Anonymize the text based on the entities.</p> Source code in <code>anonipy/anonymize/strategies/interface.py</code> <pre><code>class StrategyInterface:\n    \"\"\"The class representing the strategy interface.\n\n    All strategies should inherit from this class.\n\n    Methods:\n        anonymize(text, entities):\n            Anonymize the text based on the entities.\n\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        pass\n\n    def anonymize(self, text: str, entities: List[Entity], *args, **kwargs):\n        pass\n</code></pre>"},{"location":"references/utils/","title":"Utils Module","text":""},{"location":"references/utils/#anonipy.utils","title":"<code>anonipy.utils</code>","text":"<p>The module containing the <code>utils</code>.</p> <p>The <code>utils</code> module provides a set of utilities used in the package.</p> <p>Modules:</p> Name Description <code>regex</code> <p>The module containing the regex utilities and functions.</p> <code>file_system</code> <p>The module containing the file system utilities and functions.</p> <code>language_detector</code> <p>The module containing the language detector.</p>"},{"location":"references/utils/file_system/","title":"File System Module","text":""},{"location":"references/utils/file_system/#anonipy.utils.file_system","title":"<code>anonipy.utils.file_system</code>","text":"<p>The module containing the <code>file_system</code> utilities.</p> <p>The <code>file_system</code> module provides a set of utilities for reading and writing files.</p> <p>Functions:</p> Name Description <code>open_file</code> <p>Opens a file and returns its content as a string.</p> <code>write_file</code> <p>Writes the text to a file.</p> <code>open_json</code> <p>Opens a JSON file and returns its content as a dictionary.</p> <code>write_json</code> <p>Writes the data to a JSON file.</p>"},{"location":"references/utils/file_system/#anonipy.utils.file_system.open_file","title":"<code>open_file(file_path)</code>","text":"<p>Opens a file and returns its content as a string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.utils import file_system\n&gt;&gt;&gt; file_system.open_file(\"path/to/file.txt\")\n\"Hello, World!\"\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The content of the file as a string.</p> Source code in <code>anonipy/utils/file_system.py</code> <pre><code>def open_file(file_path: str) -&gt; str:\n    \"\"\"Opens a file and returns its content as a string.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.utils import file_system\n        &gt;&gt;&gt; file_system.open_file(\"path/to/file.txt\")\n        \"Hello, World!\"\n\n    Args:\n        file_path: The path to the file.\n\n    Returns:\n        The content of the file as a string.\n\n    \"\"\"\n\n    if not os.path.isfile(file_path):\n        raise FileNotFoundError(f\"The file does not exist: {file_path}\")\n\n    _, file_extension = os.path.splitext(file_path)\n    if file_extension.lower() == \".pdf\":\n        return _extract_text_from_pdf(file_path)\n    elif file_extension.lower() in [\".doc\", \".docx\"]:\n        return _extract_text_from_word(file_path)\n    elif file_extension.lower() == \".txt\":\n        with open(file_path, \"r\", encoding=\"utf-8\") as f:\n            return f.read()\n    else:\n        raise ValueError(f\"The file extension is not supported: {file_extension}\")\n</code></pre>"},{"location":"references/utils/file_system/#anonipy.utils.file_system.write_file","title":"<code>write_file(text, file_path, encode=True)</code>","text":"<p>Writes the text to a file.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.utils import file_system\n&gt;&gt;&gt; file_system.write_file(\"Hello, World!\", \"path/to/file.txt\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to write to the file.</p> required <code>file_path</code> <code>str</code> <p>The path to the file.</p> required <code>encode</code> <code>Union[str, bool]</code> <p>The encoding to use.</p> <code>True</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If text, <code>file_path</code> is not a string; <code>encode</code> is not a string or a boolean.</p> <code>FileNotFoundError</code> <p>If the directory does not exist.</p> Source code in <code>anonipy/utils/file_system.py</code> <pre><code>def write_file(text: str, file_path: str, encode: Union[str, bool] = True) -&gt; None:\n    \"\"\"Writes the text to a file.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.utils import file_system\n        &gt;&gt;&gt; file_system.write_file(\"Hello, World!\", \"path/to/file.txt\")\n\n    Args:\n        text: The text to write to the file.\n        file_path: The path to the file.\n        encode: The encoding to use.\n\n    Raises:\n        TypeError: If text, `file_path` is not a string; `encode` is not a string or a boolean.\n        FileNotFoundError: If the directory does not exist.\n\n    \"\"\"\n\n    if not isinstance(text, str):\n        raise TypeError(\"text must be a string\")\n\n    if not isinstance(file_path, str):\n        raise TypeError(\"file_path must be a string\")\n\n    if not os.path.exists(os.path.dirname(file_path)):\n        raise FileNotFoundError(\n            f\"The directory does not exist: {os.path.dirname(file_path)}\"\n        )\n\n    if not isinstance(encode, str) and not isinstance(encode, bool):\n        raise TypeError(\"encode must be a string or a boolean\")\n\n    encoding = None\n    if isinstance(encode, str):\n        encoding = encode\n    elif isinstance(encode, bool):\n        encoding = \"utf-8\" if encode else None\n\n    with open(file_path, \"w\", encoding=encoding) as f:\n        f.write(text)\n</code></pre>"},{"location":"references/utils/file_system/#anonipy.utils.file_system.open_json","title":"<code>open_json(file_path)</code>","text":"<p>Opens a JSON file and returns its content as a dictionary.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.utils import file_system\n&gt;&gt;&gt; file_system.open_json(\"path/to/file.json\")\n{\"hello\": \"world\"}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the JSON file.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The content of the JSON file as a dictionary.</p> Source code in <code>anonipy/utils/file_system.py</code> <pre><code>def open_json(file_path: str) -&gt; dict:\n    \"\"\"Opens a JSON file and returns its content as a dictionary.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.utils import file_system\n        &gt;&gt;&gt; file_system.open_json(\"path/to/file.json\")\n        {\"hello\": \"world\"}\n\n    Args:\n        file_path: The path to the JSON file.\n\n    Returns:\n        The content of the JSON file as a dictionary.\n\n    \"\"\"\n\n    if not os.path.isfile(file_path):\n        raise FileNotFoundError(f\"The file does not exist: {file_path}\")\n\n    with open(file_path, \"r\", encoding=\"utf-8\") as f:\n        return json.load(f)\n</code></pre>"},{"location":"references/utils/file_system/#anonipy.utils.file_system.write_json","title":"<code>write_json(data, file_path)</code>","text":"<p>Writes data to a JSON file.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.utils import file_system\n&gt;&gt;&gt; file_system.write_json({\"hello\": \"world\"}, \"path/to/file.json\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The data to write to the JSON file.</p> required <code>file_path</code> <code>str</code> <p>The path to the JSON file.</p> required Source code in <code>anonipy/utils/file_system.py</code> <pre><code>def write_json(data: dict, file_path: str) -&gt; None:\n    \"\"\"Writes data to a JSON file.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.utils import file_system\n        &gt;&gt;&gt; file_system.write_json({\"hello\": \"world\"}, \"path/to/file.json\")\n\n    Args:\n        data: The data to write to the JSON file.\n        file_path: The path to the JSON file.\n\n    \"\"\"\n\n    if not os.path.exists(os.path.dirname(file_path)):\n        os.makedirs(os.path.dirname(file_path), exist_ok=True)\n\n    with open(file_path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(data, f, ensure_ascii=False, indent=4)\n</code></pre>"},{"location":"references/utils/language_detector/","title":"Language Detector Module","text":""},{"location":"references/utils/language_detector/#anonipy.utils.language_detector","title":"<code>anonipy.utils.language_detector</code>","text":"<p>The module containing the <code>language_detector</code> utilities.</p> <p>The <code>language_detector</code> module contains the <code>LanguageDetector</code> class, which is used to detect the language of a text.</p> <p>Classes:</p> Name Description <code>LanguageDetector</code> <p>The class representing the language detector.</p>"},{"location":"references/utils/language_detector/#anonipy.utils.language_detector.LanguageDetector","title":"<code>anonipy.utils.language_detector.LanguageDetector</code>","text":"<p>The class representing the language detector.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.utils.language_detector import LanguageDetector\n&gt;&gt;&gt; detector = LanguageDetector()\n&gt;&gt;&gt; detector.detect(text)\n</code></pre> <p>Attributes:</p> Name Type Description <code>detector</code> <code>LanguageDetector</code> <p>The language detector.</p> <p>Methods:</p> Name Description <code>__call__</code> <p>Detect the language of a text. Calls the <code>detect</code> method.</p> <code>detect</code> <p>Detect the language of a text.</p> Source code in <code>anonipy/utils/language_detector.py</code> <pre><code>class LanguageDetector:\n    \"\"\"The class representing the language detector.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.utils.language_detector import LanguageDetector\n        &gt;&gt;&gt; detector = LanguageDetector()\n        &gt;&gt;&gt; detector.detect(text)\n\n    Attributes:\n        detector (lingua.LanguageDetector): The language detector.\n\n    Methods:\n        __call__(text, output_standard):\n            Detect the language of a text. Calls the `detect` method.\n\n        detect(text, output_standard):\n            Detect the language of a text.\n\n    \"\"\"\n\n    def __init__(self, low_accuracy: bool = False):\n        \"\"\"Initializes the language detector.\n\n        Examples:\n            &gt;&gt;&gt; from anonipy.utils.language_detector import LanguageDetector\n            &gt;&gt;&gt; detector = LanguageDetector()\n\n        Args:\n            low_accuracy: Whether to use the low accuracy mode.\n\n        \"\"\"\n\n        # Prepare the language detector for all languages\n        builder = LanguageDetectorBuilder.from_all_languages()\n        builder = (\n            builder.with_low_accuracy_mode()\n            if low_accuracy\n            else builder.with_preloaded_language_models()\n        )\n        self.detector = builder.build()\n\n    def __call__(\n        self, text: str, output_standard: str = \"iso_code_639_1\"\n    ) -&gt; Tuple[str, str]:\n        \"\"\"Detects the language of a text by calling the `detect` method.\n\n        Examples:\n            &gt;&gt;&gt; from anonipy.utils.language_detector import LanguageDetector\n            &gt;&gt;&gt; detector = LanguageDetector()\n            &gt;&gt;&gt; detector(text)\n\n        Args:\n            text: The text to detect the language of.\n            output_standard: The output standard.\n\n        Returns:\n            The language code.\n            The full name of the language.\n\n        \"\"\"\n\n        return self.detect(text, output_standard)\n\n    def detect(\n        self, text: str, output_standard: str = \"iso_code_639_1\"\n    ) -&gt; Tuple[str, str]:\n        \"\"\"Detects the language of a text.\n\n        Examples:\n            &gt;&gt;&gt; from anonipy.utils.language_detector import LanguageDetector\n            &gt;&gt;&gt; detector = LanguageDetector()\n            &gt;&gt;&gt; detector.detect(text)\n\n        Args:\n            text: The text to detect the language of.\n            output_standard: The output standard.\n\n        Returns:\n            The language code.\n            The full name of the language.\n\n        \"\"\"\n\n        language = self.detector.detect_language_of(text)\n        iso_code = getattr(language, output_standard).name.lower()\n        full_name = language.name.lower().title()\n        # use the correct name for Slovenian\n        full_name = \"Slovenian\" if full_name == \"Slovene\" else full_name\n        return iso_code, full_name\n</code></pre>"},{"location":"references/utils/language_detector/#anonipy.utils.language_detector.LanguageDetector.__init__","title":"<code>__init__(low_accuracy=False)</code>","text":"<p>Initializes the language detector.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.utils.language_detector import LanguageDetector\n&gt;&gt;&gt; detector = LanguageDetector()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>low_accuracy</code> <code>bool</code> <p>Whether to use the low accuracy mode.</p> <code>False</code> Source code in <code>anonipy/utils/language_detector.py</code> <pre><code>def __init__(self, low_accuracy: bool = False):\n    \"\"\"Initializes the language detector.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.utils.language_detector import LanguageDetector\n        &gt;&gt;&gt; detector = LanguageDetector()\n\n    Args:\n        low_accuracy: Whether to use the low accuracy mode.\n\n    \"\"\"\n\n    # Prepare the language detector for all languages\n    builder = LanguageDetectorBuilder.from_all_languages()\n    builder = (\n        builder.with_low_accuracy_mode()\n        if low_accuracy\n        else builder.with_preloaded_language_models()\n    )\n    self.detector = builder.build()\n</code></pre>"},{"location":"references/utils/language_detector/#anonipy.utils.language_detector.LanguageDetector.__call__","title":"<code>__call__(text, output_standard='iso_code_639_1')</code>","text":"<p>Detects the language of a text by calling the <code>detect</code> method.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.utils.language_detector import LanguageDetector\n&gt;&gt;&gt; detector = LanguageDetector()\n&gt;&gt;&gt; detector(text)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to detect the language of.</p> required <code>output_standard</code> <code>str</code> <p>The output standard.</p> <code>'iso_code_639_1'</code> <p>Returns:</p> Type Description <code>str</code> <p>The language code.</p> <code>str</code> <p>The full name of the language.</p> Source code in <code>anonipy/utils/language_detector.py</code> <pre><code>def __call__(\n    self, text: str, output_standard: str = \"iso_code_639_1\"\n) -&gt; Tuple[str, str]:\n    \"\"\"Detects the language of a text by calling the `detect` method.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.utils.language_detector import LanguageDetector\n        &gt;&gt;&gt; detector = LanguageDetector()\n        &gt;&gt;&gt; detector(text)\n\n    Args:\n        text: The text to detect the language of.\n        output_standard: The output standard.\n\n    Returns:\n        The language code.\n        The full name of the language.\n\n    \"\"\"\n\n    return self.detect(text, output_standard)\n</code></pre>"},{"location":"references/utils/language_detector/#anonipy.utils.language_detector.LanguageDetector.detect","title":"<code>detect(text, output_standard='iso_code_639_1')</code>","text":"<p>Detects the language of a text.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.utils.language_detector import LanguageDetector\n&gt;&gt;&gt; detector = LanguageDetector()\n&gt;&gt;&gt; detector.detect(text)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to detect the language of.</p> required <code>output_standard</code> <code>str</code> <p>The output standard.</p> <code>'iso_code_639_1'</code> <p>Returns:</p> Type Description <code>str</code> <p>The language code.</p> <code>str</code> <p>The full name of the language.</p> Source code in <code>anonipy/utils/language_detector.py</code> <pre><code>def detect(\n    self, text: str, output_standard: str = \"iso_code_639_1\"\n) -&gt; Tuple[str, str]:\n    \"\"\"Detects the language of a text.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.utils.language_detector import LanguageDetector\n        &gt;&gt;&gt; detector = LanguageDetector()\n        &gt;&gt;&gt; detector.detect(text)\n\n    Args:\n        text: The text to detect the language of.\n        output_standard: The output standard.\n\n    Returns:\n        The language code.\n        The full name of the language.\n\n    \"\"\"\n\n    language = self.detector.detect_language_of(text)\n    iso_code = getattr(language, output_standard).name.lower()\n    full_name = language.name.lower().title()\n    # use the correct name for Slovenian\n    full_name = \"Slovenian\" if full_name == \"Slovene\" else full_name\n    return iso_code, full_name\n</code></pre>"},{"location":"references/utils/regex/","title":"Regex Module","text":""},{"location":"references/utils/regex/#anonipy.utils.regex","title":"<code>anonipy.utils.regex</code>","text":"<p>Module containing the <code>regex</code> related utilities.</p> <p>The <code>regex</code> module provides the regex definitions and functions used within the package.</p> <p>Classes:</p> Name Description <code>RegexMapping</code> <p>The class representing the mapping for data type to the corresponding regex.</p> <p>Attributes:</p> Name Type Description <code>REGEX_STRING</code> <code>str</code> <p>The regex definition for string.</p> <code>REGEX_INTEGER</code> <code>str</code> <p>The regex definition for integer.</p> <code>REGEX_FLOAT</code> <code>str</code> <p>The regex definition for float.</p> <code>REGEX_DATE</code> <code>str</code> <p>The regex definition for date.</p> <code>REGEX_EMAIL_ADDRESS</code> <code>str</code> <p>The regex definition for email address.</p> <code>REGEX_PHONE_NUMBER</code> <code>str</code> <p>The regex definition for phone number.</p> <code>REGEX_WEBSITE_URL</code> <code>str</code> <p>The regex definition for website URL.</p>"},{"location":"references/utils/regex/#anonipy.utils.regex.REGEX_STRING","title":"<code>REGEX_STRING = '.*'</code>  <code>module-attribute</code>","text":"<p>The regex definition for string.</p>"},{"location":"references/utils/regex/#anonipy.utils.regex.REGEX_INTEGER","title":"<code>REGEX_INTEGER = '\\\\d+'</code>  <code>module-attribute</code>","text":"<p>The regex definition for integer.</p>"},{"location":"references/utils/regex/#anonipy.utils.regex.REGEX_FLOAT","title":"<code>REGEX_FLOAT = '[\\\\d\\\\.,]+'</code>  <code>module-attribute</code>","text":"<p>The regex definition for float.</p>"},{"location":"references/utils/regex/#anonipy.utils.regex.REGEX_DATE","title":"<code>REGEX_DATE = '((\\\\d{4}[-/.\\\\s]\\\\d{1,2}[-/.\\\\s]\\\\d{1,2}(?:[ T]\\\\d{2}:\\\\d{2}:\\\\d{2})?)|(\\\\d{1,2}[-/.\\\\s]\\\\d{1,2}[-/.\\\\s]\\\\d{4}(?:[ T]\\\\d{2}:\\\\d{2}:\\\\d{2})?)|(\\\\d{1,2}[-/.\\\\s]\\\\d{1,2}[-/.\\\\s]\\\\d{4}(?:[ T]\\\\d{2}:\\\\d{2})?)|(\\\\d{4}[-/.\\\\s]\\\\d{1,2}[-/.\\\\s]\\\\d{1,2}(?:[ T]\\\\d{2}:\\\\d{2})?)|(\\\\d{4}[-/.\\\\s]\\\\d{1,2}[-/.\\\\s]\\\\d{1,2}(?:[ T]\\\\d{2}:\\\\d{2} [APap][mM])?)|(\\\\d{1,2}[-/.\\\\s]\\\\d{1,2}[-/.\\\\s]\\\\d{4}(?:[ T]\\\\d{2}:\\\\d{2} [APap][mM])?)|(\\\\d{1,2}[-/.\\\\s]\\\\d{1,2}[-/.\\\\s]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}:\\\\d{2})?)|(\\\\d{4}[-/.\\\\s]\\\\d{1,2}[-/.\\\\s]\\\\d{1,2}(?:[ ]?\\\\d{2}:\\\\d{2}:\\\\d{2})?)|(\\\\d{1,2}[ ](January|February|March|April|May|June|July|August|September|October|November|December)[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}:\\\\d{2})?)|(\\\\d{1,2}[ ](Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}:\\\\d{2})?)|(\\\\d{1,2}[ ](January|February|March|April|May|June|July|August|September|October|November|December)[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}[ ]?[APap][mM])?)|(\\\\d{1,2}[ ](Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}[ ]?[APap][mM])?)|([A-Za-z]+,[ ]\\\\d{1,2}[ ](January|February|March|April|May|June|July|August|September|October|November|December),?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}:\\\\d{2})?)|([A-Za-z]+,[ ](January|February|March|April|May|June|July|August|September|October|November|December)[ ]\\\\d{1,2},?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}:\\\\d{2})?)|([A-Za-z]+,[ ]\\\\d{1,2}[ ](January|February|March|April|May|June|July|August|September|October|November|December),?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}[ ]?[APap][mM])?)|([A-Za-z]+,[ ](January|February|March|April|May|June|July|August|September|October|November|December)[ ]\\\\d{1,2},?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}[ ]?[APap][mM])?)|(\\\\d{1,2}[\\\\.]?[ ](januari|februari|maart|april|mei|juni|juli|augustus|september|oktober|november|december)[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|(\\\\d{1,2}[\\\\.]?[ ](jan|feb|mrt|apr|mei|jun|jul|aug|sep|okt|nov|dec)[\\\\.]?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([A-Za-z]+,?[ ]\\\\d{1,2}[\\\\.]?[ ](januari|februari|maart|april|mei|juni|juli|augustus|september|oktober|november|december),?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([A-Za-z]+,?[ ](januari|februari|maart|april|mei|juni|juli|augustus|september|oktober|november|december)[ ]\\\\d{1,2},?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|(\\\\d{1,2}(er)?[ ](janvier|f\u00e9vrier|mars|avril|mai|juin|juillet|ao\u00fbt|septembre|octobre|novembre|d\u00e9cembre)[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|(\\\\d{1,2}(er)?[ ](jan|f\u00e9vr|mars|avr|mai|juin|juil|ao\u00fbt|sept|oct|nov|d\u00e9c)[\\\\.]?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([A-Za-z\u00c0-\u00ff]+,?[ ]\\\\d{1,2}(er)?[ ](janvier|f\u00e9vrier|mars|avril|mai|juin|juillet|ao\u00fbt|septembre|octobre|novembre|d\u00e9cembre),?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([A-Za-z\u00c0-\u00ff]+,?[ ](janvier|f\u00e9vrier|mars|avril|mai|juin|juillet|ao\u00fbt|septembre|octobre|novembre|d\u00e9cembre)[ ]\\\\d{1,2}(er)?,?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|(\\\\d{1,2}[\\\\.]?[ ](Januar|Februar|M\u00e4rz|April|Mai|Juni|Juli|August|September|Oktober|November|Dezember)[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|(\\\\d{1,2}[\\\\.]?[ ](Jan|Feb|M\u00e4r|Apr|Mai|Jun|Jul|Aug|Sep|Okt|Nov|Dez)[\\\\.]?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([A-Za-z\u00e4\u00f6\u00fc\u00df\u00c4\u00d6\u00dc]+,?[ ]\\\\d{1,2}[\\\\.]?[ ](Januar|Februar|M\u00e4rz|April|Mai|Juni|Juli|August|September|Oktober|November|Dezember)[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([A-Za-z\u00e4\u00f6\u00fc\u00df\u00c4\u00d6\u00dc]+,?[ ](Januar|Februar|M\u00e4rz|April|Mai|Juni|Juli|August|September|Oktober|November|Dezember)[ ]\\\\d{1,2}[\\\\.]?,?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|(\\\\d{1,2}\u03b7?[ ](\u0399\u03b1\u03bd\u03bf\u03c5\u03b1\u03c1\u03af\u03bf\u03c5|\u03a6\u03b5\u03b2\u03c1\u03bf\u03c5\u03b1\u03c1\u03af\u03bf\u03c5|\u039c\u03b1\u03c1\u03c4\u03af\u03bf\u03c5|\u0391\u03c0\u03c1\u03b9\u03bb\u03af\u03bf\u03c5|\u039c\u03b1\u0390\u03bf\u03c5|\u0399\u03bf\u03c5\u03bd\u03af\u03bf\u03c5|\u0399\u03bf\u03c5\u03bb\u03af\u03bf\u03c5|\u0391\u03c5\u03b3\u03bf\u03cd\u03c3\u03c4\u03bf\u03c5|\u03a3\u03b5\u03c0\u03c4\u03b5\u03bc\u03b2\u03c1\u03af\u03bf\u03c5|\u039f\u03ba\u03c4\u03c9\u03b2\u03c1\u03af\u03bf\u03c5|\u039d\u03bf\u03b5\u03bc\u03b2\u03c1\u03af\u03bf\u03c5|\u0394\u03b5\u03ba\u03b5\u03bc\u03b2\u03c1\u03af\u03bf\u03c5)( \u03c4\u03bf\u03c5)?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|(\\\\d{1,2}i?[ ](Ianouariou|Fevrouariou|Martiou|Apriliou|Maiou|Iouniou|Iouliou|Avgoustou|Septemvriou|Oktovriou|Noemvriou|Dekemvriou)( tou)?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|(\\\\d{1,2}\u03b7?[ ](\u0399\u03b1\u03bd|\u03a6\u03b5\u03b2|\u039c\u03ac\u03c1|\u0391\u03c0\u03c1|\u039c\u03ac\u03b9|\u0399\u03bf\u03cd\u03bd|\u0399\u03bf\u03cd\u03bb|A\u03c5\u03b3|\u03a3\u03b5\u03c0|\u039f\u03ba\u03c4|\u039d\u03bf\u03b5|\u0394\u03b5\u03ba)[\\\\.]?( \u03c4\u03bf\u03c5)?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|(\\\\d{1,2}i?[ ](Ian|Feb|Mar|Apr|Mai|Iou|Ioul|Avg|Sep|Okt|Noe|Dek)[\\\\.]?( tou)?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([\\\\u0370-\\\\u03FF]+,?[ ]\\\\d{1,2}\u03b7?[ ](\u0399\u03b1\u03bd\u03bf\u03c5\u03b1\u03c1\u03af\u03bf\u03c5|\u03a6\u03b5\u03b2\u03c1\u03bf\u03c5\u03b1\u03c1\u03af\u03bf\u03c5|\u039c\u03b1\u03c1\u03c4\u03af\u03bf\u03c5|\u0391\u03c0\u03c1\u03b9\u03bb\u03af\u03bf\u03c5|\u039c\u03b1\u0390\u03bf\u03c5|\u0399\u03bf\u03c5\u03bd\u03af\u03bf\u03c5|\u0399\u03bf\u03c5\u03bb\u03af\u03bf\u03c5|\u0391\u03c5\u03b3\u03bf\u03cd\u03c3\u03c4\u03bf\u03c5|\u03a3\u03b5\u03c0\u03c4\u03b5\u03bc\u03b2\u03c1\u03af\u03bf\u03c5|\u039f\u03ba\u03c4\u03c9\u03b2\u03c1\u03af\u03bf\u03c5|\u039d\u03bf\u03b5\u03bc\u03b2\u03c1\u03af\u03bf\u03c5|\u0394\u03b5\u03ba\u03b5\u03bc\u03b2\u03c1\u03af\u03bf\u03c5),?( \u03c4\u03bf\u03c5)?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([A-Za-z]+,?[ ]\\\\d{1,2}i?[ ](Ianouariou|Fevrouariou|Martiou|Apriliou|Maiou|Iouniou|Iouliou|Avgoustou|Septemvriou|Oktovriou|Noemvriou|Dekemvriou),?( tou)?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([\\\\u0370-\\\\u03FF]+,?[ ](\u0399\u03b1\u03bd\u03bf\u03c5\u03b1\u03c1\u03af\u03bf\u03c5|\u03a6\u03b5\u03b2\u03c1\u03bf\u03c5\u03b1\u03c1\u03af\u03bf\u03c5|\u039c\u03b1\u03c1\u03c4\u03af\u03bf\u03c5|\u0391\u03c0\u03c1\u03b9\u03bb\u03af\u03bf\u03c5|\u039c\u03b1\u0390\u03bf\u03c5|\u0399\u03bf\u03c5\u03bd\u03af\u03bf\u03c5|\u0399\u03bf\u03c5\u03bb\u03af\u03bf\u03c5|\u0391\u03c5\u03b3\u03bf\u03cd\u03c3\u03c4\u03bf\u03c5|\u03a3\u03b5\u03c0\u03c4\u03b5\u03bc\u03b2\u03c1\u03af\u03bf\u03c5|\u039f\u03ba\u03c4\u03c9\u03b2\u03c1\u03af\u03bf\u03c5|\u039d\u03bf\u03b5\u03bc\u03b2\u03c1\u03af\u03bf\u03c5|\u0394\u03b5\u03ba\u03b5\u03bc\u03b2\u03c1\u03af\u03bf\u03c5)[ ]\\\\d{1,2}\u03b7?,?( \u03c4\u03bf\u03c5)?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([A-Za-z]+,?[ ](Ianouariou|Fevrouariou|Martiou|Apriliou|Maiou|Iouniou|Iouliou|Avgoustou|Septemvriou|Oktovriou|Noemvriou|Dekemvriou)[ ]\\\\d{1,2}i?,?( tou)?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|(\\\\d{1,2}\u00b0?[ ](gennaio|febbraio|marzo|aprile|maggio|giugno|luglio|agosto|settembre|ottobre|novembre|dicembre)[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|(\\\\d{1,2}\u00b0?[ ](gen|feb|mar|apr|mag|giu|lug|ago|set|ott|nov|dic)[\\\\.]?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([A-Za-z\u00c0-\u00ff]+,?[ ]\\\\d{1,2}\u00b0?[ ](gennaio|febbraio|marzo|aprile|maggio|giugno|luglio|agosto|settembre|ottobre|novembre|dicembre),?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([A-Za-z\u00c0-\u00ff]+,?[ ](gennaio|febbraio|marzo|aprile|maggio|giugno|luglio|agosto|settembre|ottobre|novembre|dicembre)[ ]\\\\d{1,2}\u00b0?,?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|(\\\\d{1,2}[\\\\.]?[ ](januar|februar|marec|april|maj|junij|julij|avgust|september|oktober|november|december)[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|(\\\\d{1,2}[\\\\.]?[ ](januarja|februarja|marca|aprila|maja|junija|julija|avgusta|septembra|oktobra|novembra|decembra)[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|(\\\\d{1,2}[\\\\.]?[ ](jan|feb|mar|apr|maj|jun|jul|avg|sep|okt|nov|dec)[\\\\.]?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([A-Za-z\u010d\u0161\u017e\u010c\u0160\u017d]+,?[ ]\\\\d{1,2}[\\\\.]?[ ](januar|februar|marec|april|maj|junij|julij|avgust|september|oktober|november|december)[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([A-Za-z\u010d\u0161\u017e\u010c\u0160\u017d]+,?[ ]\\\\d{1,2}[\\\\.]?[ ](januarja|februarja|marca|aprila|maja|junija|julija|avgusta|septembra|oktobra|novembra|decembra)[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|(\\\\d{1,2}\u00b0?( de)?[ ](enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)( de)?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|(\\\\d{1,2}\u00b0?( de)?[ ](ene|feb|mar|abr|may|jun|jul|ago|sept|oct|nov|dic)[\\\\.]?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([A-Za-z\u00c0-\u00ff]+,?[ ]\\\\d{1,2}\u00b0?( de)?[ ](enero|febrero|marzo|abril|mayo|junio|julio|augusto|septiembre|octubre|noviembre|diciembre),?( de)?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([A-Za-z\u00c0-\u00ff]+,?[ ](enero|febrero|marzo|abril|mayo|junio|julio|augusto|septiembre|octubre|noviembre|diciembre)[ ]\\\\d{1,2}\u00b0?,?( de)?[ ]\\\\d{4}(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|(\\\\d{1,2}[\\\\.]?[ ](\u0441\u0456\u0447\u0435\u043d\u044c|\u043b\u044e\u0442\u0438\u0439|\u0431\u0435\u0440\u0435\u0437\u0435\u043d\u044c|\u043a\u0432\u0456\u0442\u0435\u043d\u044c|\u0442\u0440\u0430\u0432\u0435\u043d\u044c|\u0447\u0435\u0440\u0432\u0435\u043d\u044c|\u043b\u0438\u043f\u0435\u043d\u044c|\u0441\u0435\u0440\u043f\u0435\u043d\u044c|\u0432\u0435\u0440\u0435\u0441\u0435\u043d\u044c|\u0436\u043e\u0432\u0442\u0435\u043d\u044c|\u043b\u0438\u0441\u0442\u043e\u043f\u0430\u0434|\u0433\u0440\u0443\u0434\u0435\u043d\u044c)[ ]\\\\d{4}( \u0440\u043e\u043a\u0443| \u0440\u0456\u043a)?(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|(\\\\d{1,2}[\\\\.]?[ ](sichen|lyutyi|berezen|kviten|traven|cherven|lypen|serpen|veresen|zhovten|lystopad|gruden)[ ]\\\\d{4}( roku)?(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|(\\\\d{1,2}[\\\\.]?[ ](\u0441\u0456\u0447|\u043b\u044e\u0442|\u0431\u0435\u0440|\u043a\u0432\u0456|\u0442\u0440\u0430|\u0447\u0435\u0440|\u043b\u0438\u043f|\u0441\u0435\u0440|\u0432\u0435\u0440|\u0436\u043e\u0432|\u043b\u0438\u0441|\u0433\u0440\u0443)[\\\\.]?[ ]\\\\d{4}( \u0440\u043e\u043a\u0443| \u0440\u0456\u043a)?(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|(\\\\d{1,2}[\\\\.]?[ ](sich|lyut|ber|kvi|tra|cher|lyp|ser|ver|zhov|lys|gru)[\\\\.]?[ ]\\\\d{4}( roku)?(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([\u0410-\u0429\u042c\u042e\u042f\u0490\u0404\u0406\u0407\u0430-\u0449\u044c\u044e\u044f\u0491\u0454\u0456\u0457]+,?[ ]\\\\d{1,2}[\\\\.]?[ ](\u0441\u0456\u0447\u0435\u043d\u044c|\u043b\u044e\u0442\u0438\u0439|\u0431\u0435\u0440\u0435\u0437\u0435\u043d\u044c|\u043a\u0432\u0456\u0442\u0435\u043d\u044c|\u0442\u0440\u0430\u0432\u0435\u043d\u044c|\u0447\u0435\u0440\u0432\u0435\u043d\u044c|\u043b\u0438\u043f\u0435\u043d\u044c|\u0441\u0435\u0440\u043f\u0435\u043d\u044c|\u0432\u0435\u0440\u0435\u0441\u0435\u043d\u044c|\u0436\u043e\u0432\u0442\u0435\u043d\u044c|\u043b\u0438\u0441\u0442\u043e\u043f\u0430\u0434|\u0433\u0440\u0443\u0434\u0435\u043d\u044c)[ ]\\\\d{4}( \u0440\u043e\u043a\u0443)?(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([A-Za-z]+,?[ ]\\\\d{1,2}[\\\\.]?[ ](sichen|lyutyi|berezen|kviten|traven|cherven|lypen|serpen|veresen|zhovten|lystopad|gruden)[ ]\\\\d{4}( roku)?(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([\u0410-\u0429\u042c\u042e\u042f\u0490\u0404\u0406\u0407\u0430-\u0449\u044c\u044e\u044f\u0491\u0454\u0456\u0457]+,?[ ](\u0441\u0456\u0447\u0435\u043d\u044c|\u043b\u044e\u0442\u0438\u0439|\u0431\u0435\u0440\u0435\u0437\u0435\u043d\u044c|\u043a\u0432\u0456\u0442\u0435\u043d\u044c|\u0442\u0440\u0430\u0432\u0435\u043d\u044c|\u0447\u0435\u0440\u0432\u0435\u043d\u044c|\u043b\u0438\u043f\u0435\u043d\u044c|\u0441\u0435\u0440\u043f\u0435\u043d\u044c|\u0432\u0435\u0440\u0435\u0441\u0435\u043d\u044c|\u0436\u043e\u0432\u0442\u0435\u043d\u044c|\u043b\u0438\u0441\u0442\u043e\u043f\u0430\u0434|\u0433\u0440\u0443\u0434\u0435\u043d\u044c)[ ]\\\\d{1,2}[\\\\.]?,?[ ]\\\\d{4}( \u0440\u043e\u043a\u0443)?(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([A-Za-z]+,?[ ](sichen|lyutyi|berezen|kviten|traven|cherven|lypen|serpen|veresen|zhovten|lystopad|gruden)[ ]\\\\d{1,2}[\\\\.]?,?[ ]\\\\d{4}( roku)?(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|(\\\\d{1,2}[\\\\.]?[ ](\u0441\u0456\u0447\u043d\u044f|\u043b\u044e\u0442\u043e\u0433\u043e|\u0431\u0435\u0440\u0435\u0437\u043d\u044f|\u043a\u0432\u0456\u0442\u043d\u044f|\u0442\u0440\u0430\u0432\u043d\u044f|\u0447\u0435\u0440\u0432\u043d\u044f|\u043b\u0438\u043f\u043d\u044f|\u0441\u0435\u0440\u043f\u043d\u044f|\u0432\u0435\u0440\u0435\u0441\u043d\u044f|\u0436\u043e\u0432\u0442\u043d\u044f|\u043b\u0438\u0441\u0442\u043e\u043f\u0430\u0434\u0430|\u0433\u0440\u0443\u0434\u043d\u044f)[ ]\\\\d{4}( \u0440\u043e\u043a\u0443| \u0440\u0456\u043a)?(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|(\\\\d{1,2}[\\\\.]?[ ](sichnia|liutoho|bereznia|kvitnia|travniia|chervnia|lypnia|serpnia|veresnia|zhovtnia|lystopada|hrudnia)[ ]\\\\d{4}( roku)?(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([\u0410-\u0429\u042c\u042e\u042f\u0490\u0404\u0406\u0407\u0430-\u0449\u044c\u044e\u044f\u0491\u0454\u0456\u0457]+,?[ ]\\\\d{1,2}[\\\\.]?[ ](\u0441\u0456\u0447\u043d\u044f|\u043b\u044e\u0442\u043e\u0433\u043e|\u0431\u0435\u0440\u0435\u0437\u043d\u044f|\u043a\u0432\u0456\u0442\u043d\u044f|\u0442\u0440\u0430\u0432\u043d\u044f|\u0447\u0435\u0440\u0432\u043d\u044f|\u043b\u0438\u043f\u043d\u044f|\u0441\u0435\u0440\u043f\u043d\u044f|\u0432\u0435\u0440\u0435\u0441\u043d\u044f|\u0436\u043e\u0432\u0442\u043d\u044f|\u043b\u0438\u0441\u0442\u043e\u043f\u0430\u0434\u0430|\u0433\u0440\u0443\u0434\u043d\u044f)[ ]\\\\d{4}( \u0440\u043e\u043a\u0443| \u0440\u0456\u043a)?(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([A-Za-z]+,?[ ]\\\\d{1,2}[\\\\.]?[ ](sichnia|liutoho|bereznia|kvitnia|travniia|chervnia|lypnia|serpnia|veresnia|zhovtnia|lystopada|hrudnia)[ ]\\\\d{4}( roku)?(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([\u0410-\u0429\u042c\u042e\u042f\u0490\u0404\u0406\u0407\u0430-\u0449\u044c\u044e\u044f\u0491\u0454\u0456\u0457]+,?[ ](\u0441\u0456\u0447\u043d\u044f|\u043b\u044e\u0442\u043e\u0433\u043e|\u0431\u0435\u0440\u0435\u0437\u043d\u044f|\u043a\u0432\u0456\u0442\u043d\u044f|\u0442\u0440\u0430\u0432\u043d\u044f|\u0447\u0435\u0440\u0432\u043d\u044f|\u043b\u0438\u043f\u043d\u044f|\u0441\u0435\u0440\u043f\u043d\u044f|\u0432\u0435\u0440\u0435\u0441\u043d\u044f|\u0436\u043e\u0432\u0442\u043d\u044f|\u043b\u0438\u0441\u0442\u043e\u043f\u0430\u0434\u0430|\u0433\u0440\u0443\u0434\u043d\u044f)[ ]\\\\d{1,2}[\\\\.]?,?[ ]\\\\d{4}( \u0440\u043e\u043a\u0443| \u0440\u0456\u043a)?(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?)|([A-Za-z]+,?[ ](sichnia|liutoho|bereznia|kvitnia|travniia|chervnia|lypnia|serpnia|veresnia|zhovtnia|lystopada|hrudnia)[ ]\\\\d{1,2}[\\\\.]?,?[ ]\\\\d{4}( roku)?(?:[ ]?\\\\d{2}:\\\\d{2}(?::\\\\d{2})?)?))'</code>  <code>module-attribute</code>","text":"<p>The regex definition for dates.</p>"},{"location":"references/utils/regex/#anonipy.utils.regex.REGEX_EMAIL_ADDRESS","title":"<code>REGEX_EMAIL_ADDRESS = '[a-zA-Z0-9.!#$%&amp;\u2019*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\\\.[a-zA-Z0-9-]+)*'</code>  <code>module-attribute</code>","text":"<p>The regex definition for email addresses.</p>"},{"location":"references/utils/regex/#anonipy.utils.regex.REGEX_PHONE_NUMBER","title":"<code>REGEX_PHONE_NUMBER = '[(]?[\\\\+]?[(]?[0-9]{1,3}[)]?[-\\\\s\\\\.]?([0-9]{2,}[-\\\\s\\\\.]?){2,}([0-9]{3,})'</code>  <code>module-attribute</code>","text":"<p>The regex definition for phone numbers.</p>"},{"location":"references/utils/regex/#anonipy.utils.regex.REGEX_WEBSITE_URL","title":"<code>REGEX_WEBSITE_URL = '((https?|ftp|smtp):\\\\/\\\\/)?(www.)?([a-zA-Z0-9]+\\\\.)+[a-z]{2,}(\\\\/[a-zA-Z0-9#\\\\?\\\\_\\\\.\\\\=\\\\-\\\\&amp;]+|\\\\/?)*'</code>  <code>module-attribute</code>","text":"<p>The regex definition for website URLs.</p>"},{"location":"references/utils/regex/#anonipy.utils.regex.regex_mapping","title":"<code>regex_mapping = RegexMapping()</code>  <code>module-attribute</code>","text":"<p>The shorthand to the <code>RegexMapping</code> instance.</p>"},{"location":"references/utils/regex/#anonipy.utils.regex.RegexMapping","title":"<code>RegexMapping</code>","text":"<p>The class representing the regex mapping.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.regex import regex_mapping\n&gt;&gt;&gt; regex_mapping[\"string\"]\n\".*\"\n</code></pre> <p>Attributes:</p> Name Type Description <code>regex_mapping</code> <code>defaultdict</code> <p>The mapping between the data type and the corresponding regex.</p> <p>Methods:</p> Name Description <code>__getitem__</code> <p>Gets the regex for the given type.</p> Source code in <code>anonipy/utils/regex.py</code> <pre><code>class RegexMapping:\n    \"\"\"The class representing the regex mapping.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.regex import regex_mapping\n        &gt;&gt;&gt; regex_mapping[\"string\"]\n        \".*\"\n\n    Attributes:\n        regex_mapping (defaultdict):\n            The mapping between the data type and the corresponding regex.\n\n    Methods:\n        __getitem__(type):\n            Gets the regex for the given type.\n\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the regex mapping.\n\n        Examples:\n            &gt;&gt;&gt; from anonipy.anonymize.regex import RegexMapping\n            &gt;&gt;&gt; regex_mapping = RegexMapping()\n\n        \"\"\"\n\n        self.regex_mapping = defaultdict(lambda: \".*\")\n        # Define the regex mappings\n        self.regex_mapping[ENTITY_TYPES.STRING] = REGEX_STRING\n        self.regex_mapping[ENTITY_TYPES.INTEGER] = REGEX_INTEGER\n        self.regex_mapping[ENTITY_TYPES.FLOAT] = REGEX_FLOAT\n        self.regex_mapping[ENTITY_TYPES.DATE] = REGEX_DATE\n        self.regex_mapping[ENTITY_TYPES.EMAIL] = REGEX_EMAIL_ADDRESS\n        self.regex_mapping[ENTITY_TYPES.PHONE_NUMBER] = REGEX_PHONE_NUMBER\n        self.regex_mapping[ENTITY_TYPES.WEBSITE_URL] = REGEX_WEBSITE_URL\n\n    def __getitem__(self, regex_type: str) -&gt; str:\n        \"\"\"Gets the regex for the given type.\n\n        Examples:\n            &gt;&gt;&gt; from anonipy.anonymize.regex import RegexMapping\n            &gt;&gt;&gt; regex_mapping = RegexMapping()\n            &gt;&gt;&gt; regex_mapping[\"string\"]\n            \".*\"\n\n        Args:\n            regex_type: The type of the entity.\n\n        Returns:\n            The regex for the given type.\n\n        \"\"\"\n        return self.regex_mapping[regex_type]\n</code></pre>"},{"location":"references/utils/regex/#anonipy.utils.regex.RegexMapping.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the regex mapping.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.regex import RegexMapping\n&gt;&gt;&gt; regex_mapping = RegexMapping()\n</code></pre> Source code in <code>anonipy/utils/regex.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the regex mapping.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.regex import RegexMapping\n        &gt;&gt;&gt; regex_mapping = RegexMapping()\n\n    \"\"\"\n\n    self.regex_mapping = defaultdict(lambda: \".*\")\n    # Define the regex mappings\n    self.regex_mapping[ENTITY_TYPES.STRING] = REGEX_STRING\n    self.regex_mapping[ENTITY_TYPES.INTEGER] = REGEX_INTEGER\n    self.regex_mapping[ENTITY_TYPES.FLOAT] = REGEX_FLOAT\n    self.regex_mapping[ENTITY_TYPES.DATE] = REGEX_DATE\n    self.regex_mapping[ENTITY_TYPES.EMAIL] = REGEX_EMAIL_ADDRESS\n    self.regex_mapping[ENTITY_TYPES.PHONE_NUMBER] = REGEX_PHONE_NUMBER\n    self.regex_mapping[ENTITY_TYPES.WEBSITE_URL] = REGEX_WEBSITE_URL\n</code></pre>"},{"location":"references/utils/regex/#anonipy.utils.regex.RegexMapping.__getitem__","title":"<code>__getitem__(regex_type)</code>","text":"<p>Gets the regex for the given type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anonipy.anonymize.regex import RegexMapping\n&gt;&gt;&gt; regex_mapping = RegexMapping()\n&gt;&gt;&gt; regex_mapping[\"string\"]\n\".*\"\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>regex_type</code> <code>str</code> <p>The type of the entity.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The regex for the given type.</p> Source code in <code>anonipy/utils/regex.py</code> <pre><code>def __getitem__(self, regex_type: str) -&gt; str:\n    \"\"\"Gets the regex for the given type.\n\n    Examples:\n        &gt;&gt;&gt; from anonipy.anonymize.regex import RegexMapping\n        &gt;&gt;&gt; regex_mapping = RegexMapping()\n        &gt;&gt;&gt; regex_mapping[\"string\"]\n        \".*\"\n\n    Args:\n        regex_type: The type of the entity.\n\n    Returns:\n        The regex for the given type.\n\n    \"\"\"\n    return self.regex_mapping[regex_type]\n</code></pre>"},{"location":"how-to-guides/archive/2024/","title":"2024","text":""},{"location":"how-to-guides/category/tutorial/","title":"Tutorial","text":""},{"location":"how-to-guides/category/overview/","title":"Overview","text":""}]}